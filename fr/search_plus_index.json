{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction À propos Bienvenue dans l'espace de documentation de la plateforme robotique open source Poppy. La documentation est actuellement uniquement disponible en anglais mais est en cours de traduction. Nous vous invitons à la consulter et à nous contacter sur le forum si vous avez des questions. Cette documentation est sous licence Creative Commons (BY-SA). Les sources sont disponibles sous GitHub est nous vous invitons à participer à son amélioration continue en remontant les bugs et/ou en participant à son écriture ! Version Dans ce document (version 1.0) vous trouverez les documentations pour: Poppy Humanoid 1.0.1 hardware Poppy Torso 1.0.1 hardware Poppy ErgoJr beta 6 hardware poppy_humanoid library version 1.1.1 poppy_torso library version 1.1.5 poppy_ergo_jr library version 1.4.0 poppy.creatures library version 1.7.1 pypot library version 2.10.0 "},"getting-started/":{"url":"getting-started/","title":"Démarrer","keywords":"","body":"Démarrer Le Projet Poppy est un projet sous licence libre pour la création, l'utilisation et le partage de robots interactifs réalisés par impression 3D. Il rassemble une communauté inter-disciplinaire de débutants et d'experts, de scientifiques, d'enseignants, développeurs et artistes. Ils partagent une vision: les robots sont de puissants outils d'apprentissage, de création et de collaboration afin d'améliorer le projet. Ils developpent de nouveaux comportements robotiques, créent des contenus pédagogiques, conçoivent des performances artistiques, améliorent le logiciel ou même créent de nouveaux robots. La Communauté Poppy développe des créations robotiques faciles à construire, à personnaliser et à déployer. Nous promouvons les licences libres en partageant la matériel et le logiciel. Une plateforme Web associée permet à la communauté de partager ses expériences et de contribuer à son amélioration. Pour faciliter ces échanges, deux supports sont disponibles : Le forum poppy-project pour obtenir de l'aide, discuter et échanger des idées. GitHub pour soumettre vos contributions. Toutes les sources du projet Poppy (logicielles et matérielles) sont disponibles sur GitHub. Le projet Poppy a initialement été conçu au laboratoire Inria Flowers. Les créatures Poppy Les créatures Poppy sont des robots sous licence libre, disponibles au téléchargement et pour être modifiés (Licence Creative Commons avec attribution pour le matériel et la licence GPLv3 pour le logiciel). Elles ont été conçues avec ces mêmes principes directeurs. Toutes les créatures Poppy: sont faites à partir de pièces imprimables en 3D et de moteurs Dynamixel, utilisent une carte d'extension pour le contrôle (un Raspberry Pi 2 ou Odroid pour les versions plus anciennes), sont basées sur une bibliothèque Python, pypot, qui permet le contrôle des servomoteurs Dynamixel de manière simplifiée, ont une version de simulation disponible (basée sur V-REP), peuvent être controlées en utilisant un langage de programmation visuel (Snap! une variation de Scratch) et un langage textuel Python. Elles sont aussi programmables par l'intermédiaire d'une API REST, ce qui permet de les contrôler à partir d'autre langages de programmation, viennent avec la documentation associée, des tutoriels, exemples et activités pédagogiques. Elles peuvent être utilisées telles quelles, ou modifiées pour explorer de nouvelles formes, l'ajout de capteurs, etc... Pour obtenir votre propre robot Poppy, vous pouvez soit : Vous procurer toutes les pièces vous-même en suivant la liste ci-dessous. Acheter un kit de robotique Poppy complet auprès de notre détaillant officiel. Poppy Ergo Jr Le robot Poppy Ergo Jr est un petit bras robotique à cout modéré qui possède six degré de mouvements. Il est fait de 6 moteurs au prix abordable (des servos XL-320 Dynamixel) ainsi que de parties simples et imprimables en 3D. Les pièces 3D ont été conçues pour être aisément imprimée sur un imprimante 3D courante. Les moteurs coûtent environ 20€ chacun. La carte électronique de contrôle est simple. Cela facilite la connexion de capteurs supplémentaires et est donc adapté à des objectifs pédagogiques. Vous pouvez choisir parmi les trois outils pour équiper l'extrêmité de son bras : Une lampe. Une pince. Un porte-stylo. Les rivets employés rendent le montage et démontage des outils simples. Vous pouvez les adapter en fonction de l'activité choisie. Le Ergo Poppy Jr est idéal pour débuter à manipuler des robots et apprendre la robotique sans difficultés. Il est simple à assembler, contrôler et d'un coût réduit. Vous pouvez obtenir les pièces vous-mêmes en suivant la liste des matériaux (LDM) et imprimer les pièces 3D disponibles au format STL. Pour plus d'informations, vérifiez le guide d'assemblage de l'Ergo Jr. L'Humanoïde Poppy Il s'agit d'un robot humanoïde à 25 degrés de liberté possédant une colonne vertébrale complètement motorisée. Il est utilisé pour l'éducation, la recherche (marche, interactions entre humains et robots) ou les arts (danses, performances). Du simple bras à l'humanoïde complet, cette plateforme est activement utilisée dans les laboratoires, les écoles d'ingénieur, les FabLabs, et les projets artistiques. Vous pouvez obtenir les pièces vous-mêmes en suivant la liste des matériaux (LDM) et imprimer les pièces 3D disponibles au formats STL, STEP et Solidworks 2014. Le Torse Poppy Il s'agit de la partie supérieure de l'Humanoïde Poppy (13 degrés de liberté). Le Torse Poppy est donc plus abordable que l'Humanoïde Poppy complet. Cela en fait une solution plus appropriée aux contextes éducatifs et associatifs. Le Torse Poppy peut être un bon média pour apprendre la science, la technologie, l'ingénieurie et les mathématiques (STEM). Vous pouvez obtenir les pièces vous-mêmes en suivant la liste des matériaux. Les modèles 3D pour les pièces sont identiques à celles de l'Humanoïde Poppy, sans les jambes et avec un support à ventouse supplémentaire. Autres Créatures Poppy Un aspect clef du projet Poppy est de stimuler la créativité et l'expérimentation autour de la robotique. Nous essayons de fournir tous les outils requis pour la conception de nouveaux robots basés sur les mêmes briques technologiques. Plusieurs créatures sont en cours de développement au sein de la communauté. Certaines d'entre elles vous sont présentées ci-dessous. Le Bras Droit Poppy (en construction) Le Bras Droit Poppy est une créature basée sur le bras droit de l'Humanoïde Poppy, avec 3 moteurs XL-320 additionnels à son extrémité afin d'améliorer la portée et l'agilité du bras. Il utilise le même outil pince employé par l'Ergo Jr, conçu pour saisir des objets simples. Le projet a été réalisé pendant le stage de Joel Ortiz Sosa au laboratoire Inria Flowers. Plus d'informations et les fichiers sources sont disponibles dans le dépot Github correspondant. Humanoïdes plus petits et abordables Heol Heol - qui signifie \"soleil\" en Breton - est un humanoïde de 34cm de hauteur produit par l'association Heol robotique. Il est composé de 23 moteurs, toutes les autres pièces sont imprimées en 3D. Il dépend aussi de la bibliothèque Pypot pour ses mouvements. Le but d'Heol est de faire naître un sourire sur le visage des enfants. Il peut être un outil éducatif en devenant un support d'apprentissage de la programmation et de la conception mécanique. Sa participation à la RoboCup (Tournoi international de football pour robots) est aussi envisagée. Poppyrate Il s'agit d'un robot basé sur l'Humanoïde Poppy. Il vise le développement d'une version moins chère grâce à sa taille réduite et l'usage de moteurs moins chers. La réduction de taille le rend aussi plus facile à imprimer sur une imprimante 3D courante. D'autres buts sont de le rendre aussi mobile et personnalisable que possible tant en conservant la compatibilité avec le logiciel Poppy. Poppyrate peut être vendu en kit (avec ou sans les parties 3D imprimées). Il a été conçu par la société ZeCloud. Pour plus d'informations, consultez le site Web - Twitter - Facebook! "},"getting-started/build.html":{"url":"getting-started/build.html","title":"Construire un robot","keywords":"","body":"Assembler le robot Suivant quel robot Poppy vous souhaitez utiliser, le temps d'assemblage, les compétences requises, les outils et la difficulté peuvent varier de beaucoup. Construire un Ergo Jr devrait prendre une heure et aucun outillage spécifique n'est requis, alors que l'assemblage de l'Humanoïde Poppy devrait prendre plusieurs jours et de nombreuses vis. Cette section vise à vous donner des conseils et un aperçu de quelques points importants afin que vous en soyez familiers avant d'entamer la construction. Nous allons aussi vous diriger vers les chapitres dédiés où vous trouverez les ressources et les procédures d'assemblage détaillées pas-à-pas de chaque robot. Assembler un Ergo Jr Note Vous pouvez trouver la documentation d'assemblage complète dans le chapitre assemblage pas-à-pas d'un Ergo Jr. Le robot Ergo Jr a été conçu pour être un petit robot, bon marché et facile à utiliser. Les pièces 3D ont été faites pour être imprimées facilement sur une imprimante 3D standard et les moteurs (6 servos XL-320 Dynamixel) ne coûtent que 20$ chacun. Le Ergo Jr est très facile à construire et son appendice peut être facilement changé - vous pouvez choisir parmi plusieurs outils : une lampe, une pince, un support pour stylo... Grâce aux rivets OLLO le robot est vraiment simple à assembler. Ces rivets peuvent être enlevés et ajoutés très facilement avec l'outil OLLO. Il ne devrait pas prendre plus d'une heure à être entièrement construit, ce qui permet une grande liberté de modification. Mis à part le calibrage de l'orientation des moteurs, il n'y a pas de difficulté majeure. Si vous êtes familiers avec les briques Lego, vous devriez être capable d'assembler un Ergo Jr sans trop de problèmes! Les rivets sont pensés pour être faciles à assembler et désassembler, alors en cas de problème vous pouvez simplement redémarrer à zéro! Assurez vous de configurer les moteurs avant d'assembler le robot car il est plus difficile de le faire après! Assembler un Torse ou un Humanoïde Note Vous pouvez trouver la documentation d'assemblage complète dans le chapitre assemblage pas-à-pas d'un Humanoïde Poppy. Construire un Torse Poppy ou un Humanoïde est plus complexe qu'un Ergo Jr mais ca n'est pas plus compliqué que de monter un Meccano ou un meuble Suédois. Cela consiste en les quelques étapes suivantes: assembler le support de chaque moteur: soyez très attentif à la position zéro du moteur! configurer les moteurs afin de se conformer à la configuration poppy utiliser de nombreuses vis pour connecter toutes les parties imprimées 3D aux moteurs faire un peu d'électronique pour la carte embarquée à l'intérieur de la tête : cela peut être un peu ardu si vous n'êtes pas familier avec l'électronique. La Patience et la précision sont vos alliées, mais en cas d'erreur, ne paniquez pas: Poppy est un robot prévu pour être monté et démonté. Si vous êtes attentifs aux quelques avertissements ci-dessous, et au prix de quelques essais et erreurs, vous aurez un Torse Poppy ou un Humanoïde en état de marche : Avertissement 1: L'Humanoïde Poppy et le Torse Poppy sont construits avec des moteurs servos de type Dynamixel MX-28 et MX-64. Il s'agit de moteurs puissants et ils peuvent représenter un risque de dommage pour vos doigts et les matériaux autour. Soyez prudent et placez le robot dans un espace non encombré pendant les tests que vous effectuerez. Avertissement 2: Alignez le point du support moteur (\"horn\") et le point sur l'axe du servo. Avertissement 3: Ajustez les trois points des moteurs avec les trois points de la partie structurelle. Avertissement 4: Utilisez du freinfilet afin d'éviter que les vibrations ne desserrent les vis. Par contre, tremper l'extrémité de la vis dans le freinfilet est suffisant (n'appliquez pas de freinfilet directement sur les trous de vis, cela serait trop et le démontage s'avèrerait très difficile!) Guides d'assemblage pas-à-pas : Guide pour l'Humanoïde Guide pour le Torse "},"getting-started/connect.html":{"url":"getting-started/connect.html","title":"Se connecter au robot","keywords":"","body":"Démarrer et connecter le robot Dans cette section, nous allons décrire comment démarrer votre robot et vous donner un aperçu des possibilités pour y accéder. Configurer le logiciel Les créatures Poppy viennent avec une carte embarquée dont le travail est de contrôler les moteurs et d'accéder aux capteurs. Pour une plus grande simplicité, cette carte embarquée peut être contactée à travers une interface Web. cela facilite le contrôle du robot depuis votre propre ordinateur ou une tablette sans avoir à télécharger ou installer quoique ce soit. Il y a plusieurs méthodes pour configurer la carte embarquée de votre robot Poppy : la méthode simple: utilisez une image ISO toute prête et transférez la sur une carte SD la méthode avancée: tout installer vous-même Note Si vous prévoyez d'utiliser un robot simulé, vous devez installer le logiciel sur votre propre ordinauter. Suivez les instructions pour configurer la simulation. Simplement: utiliser la Carte SD Poppy Le moyen le plus simple et le plus rapide - de loin - est d'utiliser des images ISO déjà faites pour les cartes SD. Ces images ISO viennent avec tout le nécessaire déjà pré-installé pour votre robot Poppy. C'est aussi un bon moyen de vous assurer que vous utilisez exactement le même logiciel que nous Ainsi vous éviterez de nombreux problèmes. Note Les kits de robotique Poppy viennent avec une carte SD prête à l'emploi. Ainsi vous n'avez rien de spécial à faire. Les images ISO peuvent être trouvées avec les distributions de chaque créature : pour le Poppy Ergo Jr pour le Torse Poppy pour l'Humanoïde Poppy Elles peuvent être écrites sur une carte SD d'au moins 8 Go en utilisant un outil classique. Une fois la carte SD prête, vous n'avez qu'à l'insérer dans votre carte embarquée. Vous pouvez ensuite mettre votre robot sous tension, il devrait démarrer et vous pourrez ainsi vous connecter à son interface web. Info Plus de détails dans la section Démarrage. Plus avancé: tout installer vous-même La méthode avancée consiste à installer tout le nécessaire depuis zéro. Elle suit la même procédure que nous utilisons pour générer les images ISO pour cartes SD. Nous mentionnons cette méthode car elle peut s'avérer utile si : vous travaillez avec un robot simulé et vous devez donc installer tout le logiciel nécessaire sur votre ordinateur, cette procédure est un bon endroit pour voir comment le faire sur un Raspberry Pi et l'adapter pour un autre ordinateur, vous voulez modifier l'environnement de travail, vous voulez simplement comprendre comment tout fonctionne. Attention Nous essayons de garder cette procédure d'installation aussi générique que possible. Pour autant, certains détails peuvent varier en fonction de votre système d'exploitation ou de votre ordinateur. De plus, l'installation depuis zéro demande quelques connaissances de base pour installer et configurer un environnement Python. Suivant ce que vous souhaitez accomplir, toutes les étapes ne sont pas nécessairement requises. En particulier, si vous souhaitez contrôler un robot simulé, il suffit d'installer les bibliothèques Python pour Poppy. Info Plus de détails vous sont fournis dans le chapitre Installation pour utilisateurs avancés. Configurer le réseau Une fois que votre Poppy est assemblé et son logiciel prêt, l'étape suivante est de le connecter à un réseau. Le but est de vous permettre d'accéder au robot depuis votre ordinateur ou votre tablette/smartphone, de le contrôler et de le programmer. Il y a deux manières de connecter votre robot à votre ordinateur/tablette/smartphone: Connecter le robot et l'ordinateur au même réseau (par exemple la box wifi de votre domicile ou votre établissement scolaire). Connecter directement votre robot à votre ordinateur par l'intermédiaire d'un câble ethernet. Attention Bien que connecter le robot et l'ordinateur marche pour la plupart des utilisateurs, il semble que dans certains cas cela ne fonctionne pas. Pour trouver l'adresse de votre robot sur le réseau, nous utilisons le protocole standard Zeroconf. Il vous permet d'utiliser le nom d'hôte: \"poppy.local\" en tant qu'adresse. Cela devrait fonctionner sans aucune configuration sous Mac OS et GNU/Linux. Mais cela nécessitera d'installer les Services d'impression Bonjour sous Windows. Si vous préférez, vous pouvez utiliser l'adresse IP assignée à votre robot à la place. Si vous n'êtes pas administrateur de votre réseau cela peut être assez difficile à déterminer. Dans ce cas, utilisez de préférence la première procédure. Pour vérifier que tout est configuré correctement, vous pouvez aller à l'adresse suivante avec votre navigateur web favori : http://poppy.local/. Vous pouvez remplacer poppy.local par l'adresse IP de votre robot (par exemple http://192.168.0.42). Attention Si vous n'êtes pas familier avec la configuration des réseaux ou si vous n'avez aucune idée de ce que le paragraphe précédent a tenté de vous expliquer, il est préférable de consulter un ingénieur réseau afin de compléter cette étape. Utiliser l'interface Web L'interface web est le point central pour contrôler, programmer et configurer votre robot. Elle peut être utilisée pour: Suivre l'activité du robot Le programmer en utilisant Snap! Le programmer en utilisant Python Configurer le robot (changer son nom, activer ou désactiver la caméra, le mettre à jour) Remettre à zéro et arrêter le robot. Pour accéder à cette interface, il suffit d'aller à l'URL suivante avec votre navigateur Web favori: http://poppy.local (si vous avez changé le nom de votre robot, remplacez simplement poppy par son nouveau nom) ou utilisez son adresse IP. Vous devriez voir quelque chose comme: Les boutons peuvent être utilisés pour naviguer vers les différentes fonctionnalités. Par exemple, si vous cliquez sur le Monitor and Control, vous accéderez à l'application de monitoring: Cela vous permettra d'allumer ou d'éteindre les moteurs de votre robot, de suivre leur activité, et leur comportement d'allumage et d'extinction. Le bouton What happened est là où vous devriez regarder pour plus d'information sur ce qui s'est mal passé. Voici une capture d'écran de ce que vous devriez voir si tout se passe comme prévu: "},"getting-started/program-the-robot.html":{"url":"getting-started/program-the-robot.html","title":"Programmer le robot","keywords":"","body":"Programmer le robot Les robots Poppy sont conçus pour être faciles à programmer. Trois options sont présentées ici: avec Snap!, une variante de Scratch, un langage de programmation visuel, avec Python pour bénéficier de toute la puissance de l'interface de programmation, à travers l'interface REST qui vous permet de contrôler les robots Poppy avec d'autres équipements et n'importe quel langage de programmation. Info Comme pour le reste du projet, toutes nos bibliothèques sont sous licence libre et disponibles sur GitHub. Utiliser Snap Snap! est un langage de programmation visuel - une variante du célèbre langage Scratch. C'est un langage de programmation basé sur des blocs à connecter ensemble, permettant une introduction très complète à l'informatique. Il fonctionne dans votre navigateur Web et est implémenté en Javascript. Nul besoin d'installer quoique ce soit afin de l'utiliser. Il existe sous licence libre et est activement maintenu. Nous avons développé un ensemble de blocs spécifiques pour les robots Poppy qui permettent d'envoyer des commandes moteur et de lire des valeurs en provenance des capteurs de votre robot. Cela vous permet de vous immerser dans le contrôle et la programmation de votre robot sans problèmes de compilation ou de syntaxe. Grâce à la boucle d'interaction continuelle de Snap! il suffit de cliquer sur un bloc pour envoyer la commande associée au robot. Snap! s'applique aussi tout naturellement aux projets plus complexes. Un chapitre dédié vous guidera dans ce que vous pouvez faire avec Snap! et les robots Poppy. Utiliser Python Les bibliothèques Poppy ont été écrites en Python, pour permettre un développement rapide et extensible, et pour bénéficier de toutes les bibliothèques scientifiques existantes. Python est aussi un langage très répandu et largement utilisé dans les sphères pédagogiques et artistiques. En programmant Poppy en Python, vous aurez accès tant aux fonctions de bas niveaux qu'à celles de plus haut niveau. L'interface de programmation (API) a été conçue pour le prototypage rapide. Créer un robot et commencer à mouvoir ses moteurs ne devrait pas prendre plus de quelques lignes: from poppy.creatures import PoppyErgoJr jr = PoppyErgoJr() jr.m3.goal_position = 30 Nous sommes aussi de grands fans du projet Jupyter et de ses \"Notebooks\". Les \"Notebooks\" sont des documents qui peuvent aussi bien contenir du code Python et du texte formatté que des équations, des images ou des vidéos. Ils peuvent être édités depuis l'interface Web Jupyter ce qui permet aux utilisateurs de programmer les robots Poppy depuis un site web hébergé sur l'ordinateur même du robot. Nous pensons qu'il s'agit là d'un outil puissant pour permettre la création et le partage de code vivant, de visualisations des résultats et du texte explicatif combinés en un seul document. La plupart des tutoriels, des expériences et des activités pédagogiques que nous et notre communauté développent sont disponibles sous forme de Notebooks Jupyter. Info Une gallerie de Notebooks mise à jour peut être trouvée ici. Vos contributions sont les bienvenues! Avec l'interface REST En plus des options Snap! et Python, nous voulions fournir un autre moyen d'accéder et de contrôler votre robot depuis n'importe quel appareil ou langage de programmation. Les robots Poppy exhibent une interface REST. Les fonctionnalités principales du robot sont donc accessibles par des requêtes HTTP GET/POST. D'un point de vue plus pratique, cela vous permet de pouvoir: Ecrire des connecteurs pour contrôler les robots Poppy depuis n'importe quel langage de programmation (de formidables contributeurs ont déjà écrit des connecteurs Matlab et Ruby ). Concevoir des applications web connectées à votre robot, telles que cette interface de suivi (aussi une contribution!). Faire interagir votre robot avec d'autres appareils connectés tels qu'un smartphone, des capteurs intelligents, ou même votre compte Twitter... Attention L'interface REST est encore en cours de réalisation, elle va certainement changer et est actuellement en manque de documentation ! Pour plus d'informations, veuillez consulter cette page ou notre forum. Une interface REST bien conçue, stable et bien documentée est attendue pour la prochaine version majeure de notre logiciel. "},"getting-started/visualize.html":{"url":"getting-started/visualize.html","title":"Visualiser","keywords":"","body":"Visualiser le robot dans un simulateur Créatures Poppy simulées Des versions simulées de tous les robots Poppy (Humanoïde, Torse, and Ergo Jr) sont disponibles. Des connexions avec deux simulateurs populaires ont été développées : avec V-REP: une plateforme d'expérimentation robotique virtuelle avec un visualisateur web 3D: plus léger mais sans support pour la physique. Attention Actuellement, seul le Poppy Ergo Jr peut être utilisé dans le visualisateur web. Si vous souhaitez simuler d'autres créatures, vous devez utiliser V-REP. Le support pour d'autres robots est en préparation mais pas dans un avenir immédiat. Nous pensons que la simulation peut être un outil puissant. Elle permet de développer et de tester des programmes sans avoir besoin d'un vrai robot. Cela est particulièrement utile: Pour découvrir et essayer les possibilités du robot sans dépenser quoique ce soit. Dans un contexte où plusieurs utilisateurs doivent partager un robot. Par exemple dans une salle de classe où chaque groupe peut travailler avec le simulateur puis valider son travail sur un vrai robot. Pour concevoir et exécuter des expériences compliquées et coûteuses en temps. Nous essayons de rendre la transition du robot Poppy simulé vers le vrai robot aussi transparente et simple que possible. Notre documentation est tout à fait valide à la fois pour le robot simulé et le vrai robot. Le chapitre De la simulation au vrai robot vous guidera dans les quelques étapes nécessaires pour transformer votre programme de simulation vers un programme fonctionnant sur un vrai robot. Attention Si vous voulez utiliser les robots Poppy dans un simulateur, il faut installer quelques bibliothèques Poppy sur votre ordinateur. Installer le logiciel requis Bien que les robots physiques viennent les bibliothèques pré-installées, elles ne sont pas intégrées dans les simulateurs. Vous devrez donc les installer sur votre ordinateur. Plus de détails sur ce que vous aurez à faire vous est donné dans la section ci-dessous. Vous n'aurez pas non plus accès à l'interface web du robot. Vous devrez lancer manuellement les différents services pour commencer à programmer votre robot (par exemple le serveur Jupyter pour les Notebooks en Python, ou le serveur Snap!). Info Nous espérons fournir une application facile à installer pour Windows/Mac/Linux fournissant tout le nécessaire à une date ultérieure, mais pas dans un futur immédiat. Pour commencer à contrôler votre robot Poppy de simulation, avec soit V-REP ou le visualisateur Web, vous aurez besoin de: Obtenir un environnement Python fonctionnel, nous vous encourageons à utiliser la distribution Anaconda Python. Elle fonctionne avec toute version >=2.7 ou >=3.4. Préférez la version Python 2.7 si vous pouvez car il s'agit de la version que nous avons utilisée. Installer les bibliothèques Poppy : pypot et la bibliothèque correspondant à votre créature (par exemple poppy-ergo-jr). Note Des détails sur ces étapes peuvent être trouvées dans la section Installer localement le logiciel pour usage avec un simulateur. Utiliser V-REP V-REP est un simulateur puissant et très répandu. Il est largement utilisé à des fins de recherche et d'enseignement. Il est de plus disponible gratuitement sous une licence éducative. Il peut être téléchargé depuis ce site web (il fonctionne sous Mac OS, Windows et GNU/Linux). Attention Il est important de noter que V-REP simule tous les aspects de la physique et de l'affichage du robot, il peut être lent si vous ne disposez pas d'un ordinateur puissant (notamment en terme de carte graphique). Les principaux robots Poppy sont disponibles dans V-REP: Humanoïde Poppy Torse Poppy Poppy Ergo Jr V-REP peut être utilisé pour apprendre à contrôler les moteurs, obtenir de l'information des capteurs mais aussi interagir avec un environnement simulé. Il peut être contrôlé avec Python, Snap! ou par l'interface REST. Voici quelques exemples de ce que la communauté a pu faire avec: Une activité pédagogique pour découvrir les différents moteurs de votre robot et comment les contrôler. Une expérience scientifique, dans laquelle un Torse Poppy apprend à pousser le cube qui se trouve sur la table en face de lui. Note Malgré nos efforts pour reproduire le comportement et le fonctionnement du robot, quelques différences subsistent. En particulier, si vous faites marcher le robot en simulation, cela ne signifie pas forcément qu'il fonctionnera dans le monde réel (et vice-versa). Utiliser notre visualisateur web Notre visualisateur web - basé sur la bibliothèque Three.js - vous montrera une représentation 3D de votre robot Poppy. Pour cela vous aurez besoin de le connecter soit à un vrai robot (à travers l'interface REST) ou à un robot de test tournant sur votre ordinateur. Il suffit de régler la variable hôte avec l'adresse de votre robot depuis l'interface Web. Note Un robot de test peut être démarré avec la commande poppy-services. Par exemple: poppy-services --poppy-simu --snap poppy-ergo-jr Comme pour V-REP, vous pouvez contrôler votre robot en utilisant Python, Snap!, ou l'interface REST. En revanche, il n'y a pas de simulation physique, cela demande donc moins de ressources mais vous ne pourrez pas interagir avec des objets. Voici un exemple avec Python: "},"getting-started/example-of-projects.html":{"url":"getting-started/example-of-projects.html","title":"Exemples de projets","keywords":"","body":"Aperçu des projets développés par la communauté La communauté Poppy rassemble une communauté interdisciplinaire de débutants et d'experts, de scientifiques, d'éducateurs, de développeurs et d'artistes. De nombreuses créations robotiques ont émergées. En voici quelques-unes illustrées ci-dessous. School of Moon La pièce School of moon a été créée par la troupe de danse contemporaine Shonen conduite par le choréographe Eric Minh Cuong Castaing. La scène est partagée avec des enfants, deux danseurs (Gaëtan Brun Picard and Ana Pi), 3 Robots Nao et deux robots Humanoïdes Poppy. Cette pièce est une métaphore de la création d'une post-humanité en trois actes: l'Homme, l'Homme et la Machine, et la Machine. Les représentations sont adaptées à l'endroit où elles se tiennent, les enfants participants à la danse appartiennent à la communauté locale. Il y a aussi des séquences spécifiques suivant les robots disponibles dans la ville. Les défis artistiques sont: de diriger des enfants sur scène d'avoir des interactions entre humains et robots sur scène d'avoir des robots sur scène. La création s'est tenue sur quatre périodes de temps: 2 semaines en résidence au CDC de Toulouse (France) en Septembre 2015 2 semaines en résidence au KLAP de Marseille (France) en Décembre 2015 4 semaines en résidence au Ballet National de Marseille (France) en Janvier 2016 2 semaines en résidence à Düsseldorf (Germany) Le Projet Cherry Le projet Cherry est un projet communautaire pour déveloper des scénarios afin de réduire l'isolation des enfants à l'hôpital. Ce projet utilise le robot Poppy comme compagnon pour les enfants hospitalisés. Cherry peut compenser la rupture sociale durant l'hospitablisation. Il agit comme médiateur entre l'enfant, ses amis, sa famille et les enseignants, et peut lui parler ou jouer avec lui. Il agit aussi au niveau pédagogique, en encourageant l'enfant à interagir avec l'école, en offrant des quizz et des jeux éducatifs. Enfin, un dernier aspect est d'assister le personnel médical dans l'éducation thérapeutique. En effet, un message est parfois plus acceptable pour l'enfant s'il est délivré par un robot, plutôt que par un adulte habillé comme un médecin. Plus d'information: La page facebook Le flux twitter Le blog wordpress Le dépôt github (avec un wiki) Connecter Poppy et Arduino grâce à Snap4Arduino Gilles, enseignant et \"maker\" à ses heures perdues, a développé de nombreux projets basés sur le Poppy Ergo Jr et Arduino. Pour connecter les deux mondes, il utilise Snap4arduino. Alors, il devient très aisé et élégant de les faire communiquer. Vous pouvez combiner Arduino avec des blocs Poppy et voilà !! Vous pouvez contrôler votre robot avec n'importe quel capteur basé sur Arduino. La seule limite est alors votre créativité! Par exemple, vous pouvez faire Poppy Ergo Jr jouer au Morpion: La documentation détaillée peut être trouvée dans la section Contrôler Poppy avec Arduino. "},"installation/":{"url":"installation/","title":"Installation","keywords":"","body":""},"installation/install-zeroconf.html":{"url":"installation/install-zeroconf.html","title":"Install a zeroconf client","keywords":"","body":"Zeroconf Zeroconf also called Bonjour (name of Apple implementation) is set of technologies that allow more easily communication between computers without configuration. Info Zeroconf is not mandatory on your computer to use Poppy robots, but we will assume it is installed. It is more convenient and readable for the documentation. Installation On Windows, you have to install Bonjour print services for Windows (yes, it is an Apple software). On GNU/Linux, you have to install avahi-daemon (mDNS) and avahi-autoipd (IPv4LL), it may or may not be installed by default depending on your installation. Run sudo apt-get install avahi-daemon avahi-autoipd on Debian/Ubuntu or sudo yum install avahi-daemon avahi-autoipd on Fedora. On Mac OSX it works out of the box. You ready to follow your installation path. What Zeroconf does for you Local domain name Zeroconf client publishes a decentralised local domain name (mDNS) with the '.local' top level domain. It means that you can join any local local computer by its hostname with the '.local' suffix instead of its IP address. With a zeroconf client, to ping a computer called (hostname) 'goldstine', you can simply do: $ ping goldstine.local 64 bytes from 192.168.1.42: icmp_seq=0 ttl=54 time=3.14 ms [...] You no longer need to look for its IP address on your local network; you don't even need to understand what an IP address is. It also work on your web browser. To open the website hosted on the robot computer called 'goldstine', you have to open: http://goldstine.local on your favorite web browser URL field. Link-local IPv4 addresses Among other Zeroconf tools, there is an implementation of decentralized DHCP (IPv4LL), which allow computers obtain an IP and connect each others without a DHCP server. The auto-adressed IP is in the APIPA range, from 169.254.0.0 to 169.254.255.255. You can plug a robot to your computer directly on your computer with an Ethernet cable, without any router and connect it with its local domain name (hostname.local). Warning You will be able to use the local-link IPv4 address only if you installed your robots after end of May 2016. Previously avahi-autoipd packet was missing. Alternatives to find the IP address of a computer on your local network If you cannot (or doesn't want to) install a zeroconf client on your personal computer, you can use one of the following methods to find the IP address of your robot. You can use Fing, famous for its Android and iOS applications, Nmap (only GNU/Linux and MAC OSX) if you are not afraid of command line interfaces. You can also go to your router web interface (with its IP address on your web browser like http://192.168.0.1 or http://192.168.1.1 or http://192.168.0.254 or http://192.168.1.254), you should have a section of connected hosts. **Caution** This paragraph is not currently written. Your help is welcome to fulfill it ! --> "},"installation/burn-an-image-file.html":{"url":"installation/burn-an-image-file.html","title":"Startup with a Poppy robot","keywords":"","body":"Startup with a Poppy robot Note This chapter is only for people who want to control a tangible robot. If you intend to control a simulated robot on your computer, look at the simulation install path. Poppy creatures are controlled by a small embedded computer: a Raspberry Pi or an Odroid board. The operating system of this computer is hosted on a SD card (you can also use an MMC for the Odroid). You may be in two kind of cases: You already have a SD card with the Poppy operating system (provided by one of the Poppy distributors for example). You're ready to go to the assembly section. You have an empty SD-card, so you have to download and write the operating system on the SD card. Info The Poppy creatures operating system use a GNU/Linux distribution, but you won't have to any knowledges on Linux to install the image on the Raspberry Pi. You will only need a computer with a SD card reader/writer to write the image on the SD card. Download the image of the operating system You have to choose the image (file in *.img.zip) to download depending on your Poppy creature and the targeted board: Ergo Jr Poppy Torso Poppy Humanoid The .zip file you have downloaded need to be unzipped to get the image file for writing to your SD card. Write the operating system image to the SD card With the image file corresponding to your Poppy creature, you need to use an image writing tool to install it on your SD card. First unzip the image you have previously downloaded. Burn the image with etcher (GUI software) Download and install etcher. It works for Windows, OSX, and GNU/Linux operating systems. Select the unzipped image, select the SD-card or MMC drive, press the burn button, and wait until it is done. Now you are ready to assemble your robot! Burn the image with dd (CLI software) Warning This method works only for GNU/Linux and OSX operating systems, and is not recommended if you don't understand what you do. Run df -h to see what devices are currently mounted. If your computer has a slot for SD cards, insert the card. If not, insert the card into an SD card reader, then connect the reader to your computer. The new device that has appeared is your SD card. The left column gives the device name of your SD card; it will be listed as something like /dev/mmcblk0p1 or /dev/sdd1. The last part (p1 or 1 respectively) is the partition number but you want to write to the whole SD card, not just one partition. Therefore you need to remove that part from the name (getting, for example, /dev/mmcblk0 or /dev/sdd) as the device for the whole SD card. Note that the SD card can show up more than once in the output of df; it will do this if you have previously written a Raspberry Pi image to this SD card, because the Raspberry Pi SD images have more than one partition. Run umount /dev/sdd1, replacing sdd1 with the device name of your SD card (including the partition number). In the terminal, write the image to the card with the command below, making sure you replace the input file if= argument with the path to your .img file, and the /dev/sdd in the output file of= argument with the right device name. Caution You will lose all data on your hard drive if you provide the device name of another running partition. Make sure the device name is the name of the whole SD card as described above, not just a partition of it; for example sdd, not sdds1 or sddp1; or mmcblk0, not mmcblk0p1. If you are running a GNU/Linux OS: sudo dd bs=4M if=poppy-ergojr.img of=/dev/mmcblk0 If you are running OSX or another BSD based OS: sudo dd bs=4m if=poppy-ergojr.img of=/dev/rdisk2 Info The dd command does not give any information of its progress and so may appear to have frozen; it > could take more than five minutes to finish writing to the card. To see the progress of the copy operation you can run sudo pkill -USR1 -n -x dd in another terminal. Run sync; this will ensure the write cache is flushed and that it is safe to unmount your SD card. Remove the SD card from the card reader. Now you are ready to assemble your robot! "},"installation/install-poppy-softwares.html":{"url":"installation/install-poppy-softwares.html","title":"Install Poppy softwares","keywords":"","body":"Install Poppy softwares Warning If you want to install the board of a tangible robot, go to the startup chapter instead. This section will guide you to install Poppy softwares on your personal computer. It is useful only if you are in one of these situations: You want to control a simulated robot. You want to control a Poppy creature from your computer without using the embedded board (Odroid or Raspberry Pi). Poppy creatures are run by Python computer code. Depending on your operating system you will have to install Python and in any case you'll have to install the required software libraries. If you are getting started with Python and want to install a full Python environment for scientific computing, we suggest you to use Anaconda Python distribution. Install Python and Poppy software on Windows Install Python and Poppy softwares on Windows Install Poppy software on Windows Upgrade Poppy software on Windows Install Python and Poppy software on Mac OSX Install Python and Poppy software on GNU/Linux Install dependancies with your operating system package manager (alternative solution to Anaconda/Miniiconda) Install Poppy software on GNU/Linux Upgrade Poppy software on GNU/Linux Install Python and Poppy software on Windows If you want a step by step screencast of the installation of Anaconda on Windows, you can see these videos (this is a YouTube playlist). Install Python and Poppy softwares on Windows We encourage the use of the Anaconda Python distribution. However, if you already installed a Python distribution like Canopy (shipped with scientific packages), you can directly install Poppy software. Info Poppy software libraries work in Python 2.7 and Python 3.3+. If you have no ideas on which version to install, we suggest you to use Python 2.7 as we develop in this version. Anaconda Python distribution Download Anaconda Python distribution (400 MB) here for 64-bit computer or here for 32-bit. Install it by clicking on \"next\" at each step. If you intend to install Anaconda for all users of your computer, be sure to select \"all users\". . It is also very important that the two check-boxes of the PATH and the default Python are checked. Now you have a Python distribution, you are ready to install Poppy software. Miniconda Python (alternative to Anaconda) Miniconda is a \"light\" version of Anaconda which contain only Python and the conda package manager. You can install it instead of Anaconda and save a lot of disk space (25 Mo vs 400 Mo), but you will have to do another step in the install process, and you will not have Jupyter notebook shortcut on the desktop. Download miniconda here for 64-bit computer or here for 32-bit computer. Install it and be sure that the two check-boxes of the PATH and the default Python are checked. Open the Command Prompt (press the windows key and type \"Command Prompt\"), type and press Enter to execute the command below: conda install numpy scipy notebook jupyter matplotlib Now you have a Python distribution ready to install Poppy software. Install Poppy software on Windows Open the prompt of your Python Distribution (called Anaconda Prompt for Anaconda) or the Command Prompt of Windows, type and press Enter to execute the command below: . Note Substitute \"poppy-ergo-jr\" with \"poppy-torso\" or \"poppy-humanoid\" to install respectively a Poppy Torso or a Poppy Humanoid. pip install poppy-ergo-jr This will install everything necessary to control a Poppy Ergo Jr. Upgrade Poppy software on Windows In case of update, it is advised to upgrade pypot (the motor library control) and the creature package separately: Note Substitute \"poppy-ergo-jr\" with \"poppy-torso\" or \"poppy-humanoid\" to install respectively a Poppy Torso or a Poppy Humanoid. pip install pypot --upgrade --no-deps pip install poppy-creature --upgrade --no-deps pip install poppy-ergo-jr --upgrade --no-deps Info To understand commands above --upgrade will uninstall before starting the install --no-deps will avoid installing dependencies, this is usefull to avoid pip to compile scipy as it will probably fail of you have not GCC and Fortran dependancies. Install Python and Poppy software on Mac OSX Mac OSX has a Python distribution installed by default. Before installing Poppy software, you need to install the Python package manager pip. Open a terminal copy and press enter to execute the command below: curl --silent --show-error --retry 5 https://bootstrap.pypa.io/get-pip.py | sudo python You can now install Poppy software for the creature of your choice: Note Substitute \"poppy-ergo-jr\" with \"poppy-torso\" or \"poppy-humanoid\" to install respectively a Poppy Torso or a Poppy Humanoid. pip install poppy-ergo-jr --upgrade Install Python and Poppy software on GNU/Linux Most of GNU/Linux distributions, have already a Python distribution installed by default, but if Install Miniconda Python distribution Info Poppy software libraries work in Python 2.7 and Python 3.3+. If you have no ideas on which version to install, we suggest you to use Python 2.7 as we develop in this version. If you want to have up-to-date numpy, scipy and jupyter without having to compile them, we suggest you to install Anaconda or at least the conda package manager distributed with miniconda. Download miniconda (64-bit) with these command below in your terminal: curl -o miniconda.sh http://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh If you have a 32-bit computer curl -o miniconda.sh http://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86.sh Execute commands below and follow the instructions to install miniconda: chmod +x miniconda.sh ./miniconda.sh You can now install some required and other useful dependencies for Poppy software with conda: conda install numpy scipy notebook jupyter matplotlib You can now install Poppy software. Install dependancies with your operating system package manager (alternative solution to Anaconda/Miniiconda) Pypot, the main library of the robot is depending (amongst some other) on two big scientific libraries Numpy and Scipy which are themselves depending on C and Fortran code. These libraries may be installed with the Python package system (pip), but because of the huge number and differences between GNU/Linux distributions pip is not able to distribute binaries for Linux so all dependencies must be compiled... The solution to avoid the compilation of numpy and scipy is to install them with your distribution package manager. On Ubuntu & Debian: curl --silent --show-error --retry 5 https://bootstrap.pypa.io/get-pip.py | sudo python sudo apt-get install gcc build-essential python-dev python-numpy python-scipy python-matplotlib sudo pip install jupyter On Fedora: curl --silent --show-error --retry 5 https://bootstrap.pypa.io/get-pip.py | sudo python sudo yum install gcc python-devel numpy scipy python-matplotlib sudo pip install jupyter On Arch Linux: curl --silent --show-error --retry 5 https://bootstrap.pypa.io/get-pip.py | sudo python sudo pacman -S python2-scipy python2-numpy python2-matplotlib sudo pip install jupyter You can now install Poppy software. Note The downside is the Python libraries from you distribution system are very often out of date. Install Poppy software on GNU/Linux Open the terminal, copy and press enter to execute the command below: Note Substitute \"poppy-ergo-jr\" with \"poppy-torso\" or \"poppy-humanoid\" to install respectively a Poppy Torso or a Poppy Humanoid. pip install poppy-ergo-jr --user This will install everything necessary to control a Poppy Ergo Jr. Upgrade Poppy software on GNU/Linux In case of update, it is advised to upgrade pypot (the motor library control) and the creature package separately: Note Substitute \"poppy-ergo-jr\" with \"poppy-torso\" or \"poppy-humanoid\" to install respectively a Poppy Torso or a Poppy Humanoid. pip install pypot --upgrade --no-deps pip install poppy-creature --upgrade --no-deps pip install poppy-ergo-jr --upgrade --no-deps Info To understand commands above --user will install Python package in user directories, it avoid using sudo if you use the Python of your OS. --upgrade will uninstall before starting the install --no-deps will avoid installing dependencies, this is usefull to avoid pip to compile scipy as it will probably fail of you have not Fortran dependancies "},"installation/install-vrep.html":{"url":"installation/install-vrep.html","title":"Install V-REP simulator","keywords":"","body":"Install the robotic simulator V-REP Info You need to install Poppy softwares before installing the V-REP simulator. V-REP is an efficient robotic simulator mainly open source (GNU GPL), which is distributed under a free license for educational entities and have a commercial license for other purposes. There is also an PRO EVAL version which limit the right to backup. As you don't need to backup the scene to use V-REP with pypot (the Python library made for Poppy creatures), we suggest you to install this version to not worry about copyright infringement. If you want to modify the V-REP scene for adding or customizing a Poppy creature, you will have to use the PRO or the EDU version (look at the educational license). Install V-REP on Windows Download V-REP PRO EVAL or EDU (if you are an educational entity). As V-REP is not signed, you will have to pass the Windows SmartScreen (on Windows 10) popup to begin the installation. During the installation, make sure to install Visual C++ Redistributable 2010 and Visual C++ Redistributable 2012. Even if you already have Visual C++ Redistributable 2010 or Visual C++ Redistributable 2012, it is advised to \"repair\" them (it is a re-installation process). After the installation you can test if V-REP works well. Install on MAC OSX Caution This paragraph is not currently written. Your help is welcome to fulfill it ! Install on GNU/Linux Caution This paragraph is not currently written. Your help is welcome to fulfill it ! Test your installation Open V-REP with a double click on the desktop icon. Open the prompt of your Python Distribution (called Anaconda Prompt for Anaconda) or the Command Prompt of Windows, type and press Enter to execute the command below: poppy-services --snap --vrep --no-browser poppy-torso` After a one or two seconds, you will have an error like the picture below in your Command prompt. If you switch to the V-REP window, a popup appeared to inform you that the simulation use custom parameters. This popup block the communication to the Python API of V-REP. You have to check the check-box \"Do not show this message again\" and press \"Ok\". Switch the the command prompt window. You will have to execute the last command (poppy-services --snap --vrep --no-browser poppy-torso) and click again to the V-REP popup (with the check-box checked). This process will have to be done three times to make it works well! Info To avoid retyping the same command again and again, you can press the up arrow key to call the last typed line. When the setup of V-REP is ready, you can execute the last command without the \"--no-browser\" part. poppy-services --snap --vrep poppy-torso If you see a firewall popup like the picture below, be sure to check the \"private network\" check-box. If everything works, a new tab have been opened on your default web-browser. You can program you robot in Snap! or in Python. "},"installation/install-drivers.html":{"url":"installation/install-drivers.html","title":"Install USB to serial drivers","keywords":"","body":"Install drivers Caution This chapter is only for people who want to control a tangible robot without an embedded board (Raspberry Pi or Odroid). It is a special case for advanced users. If you intend to control tangible robots from your computer without a Raspberry Pi or a Odroid, and you use a computer with Windows (vs GNU/Linux or MAC OSX), you may need to install manually drivers for the USB2AX or the USB2Dynamixel. If you use a USB2AX If the USB2AX is not recognized out of the box (its LED stay red after having been plugged) on your computer, you probably need to install manually its drivers. The installation process and the files to download can be found on the USB2AX documentation. You don't need drivers for GNU/Linux or MAC OSX, but note that it doesn't works very well with MAC OSX. If you want to control XL-320 motors (protocol Dynamixel v2) from an USB2AX you may need to update the firmware to the version 04 of the USB2AX. If you use a USB2Dynamixel You need to install FTDI drivers on your computer. You have to low the \"Latency Timer Value\" from 16ms to 1ms (minimum allowed value) as explained in the FTDI documentation to avoid pypot timeouts. "},"installation/install-a-poppy-board.html":{"url":"installation/install-a-poppy-board.html","title":"Install a Poppy Board","keywords":"","body":"Install a Poppy board Caution This chapter is only for people who want to create from scratch a Raspberry Pi or Odroid image. It is strongly advised to simply burn a pre-made system image on your robot. To install a Poppy board, we start from a vanilla distribution (Debian or Ubuntu), remove some useless stuff and launch some scripts. Keep in mind that our install scripts are not written for end users: it is not well maintained and there is almost no error messages. If you encounter issues with these scripts, you can post a message in the support section of the forums. For a Poppy Ergo Jr / Raspberry Pi Raspberry Pi are preformated with n00b, you need to install Raspbian first. Download the image of your system: Raspbian Jessie if you are using a Raspberry Pi 2. Write the image to the SD-card with you favorite disk writer tool as explained in the startup section. Info If you are using Windows, you have no native SSH client ; you have to download and install putty or mobaxterm to use SSH. Login to the board in SSH: ssh pi@raspberrypi.local, password=raspberry. You will need to make sure that you have enough free space in your raspberry. The easiest way is to use the raspi-config script to expand your partition to the full SD-card. Just log into your raspberry and run (you will need to reboot it afterwards): sudo raspi-config --expand-rootfs Be sure that your board is connected to the Internet, and use \"raspoppy\" installer: curl -L https://raw.githubusercontent.com/poppy-project/raspoppy/master/raspoppyfication.sh | bash -s \"poppy-ergo-jr\" Reboot after the end of the installation. The hostname, default user and password will be all set to \"poppy\" (ssh poppy@poppy.local password=poppy). You can test your installation with the web interface in your web browser http://poppy.local. Install a Poppy Torso / Humanoid on a Odroid U3 or Odroid XU4 These boards come with a working Ubuntu base image on the MMC you can use the install scripts on it. In the case you have not a fresh installation you have download and burn default system images: Ubuntu 14.04 for Odroid U3 Ubuntu 14.04 for Odroid XU3/XU4 To burn it on the MMC/SD-card, look at the startup section. Now you have a clean and fresh installation, you can mount your memory card to your board, plug your ethernet connection, and power up. Login to the board in SSH: ssh odroid@odroid.local, password=odroid. Info If you are using Windows, you have no native SSH client ; you have to download and install putty or mobaxterm to use SSH. Be sure that your board is connected to the Internet, download and run poppy_setup.sh (replace 'poppy-humanoid' below with poppy-torso' if you want to install a Poppy Torso robot): wget https://raw.githubusercontent.com/poppy-project/odroid-poppysetup/master/poppy_setup.sh -O poppy_setup.sh sudo bash poppy_setup.sh poppy-humanoid You should lose your ssh connection because of the board reboot. This reboot is needed to proceed to the finalisation of the partition resizing. Now your board should install all the poppy environment. Please do not unpower the board or shut-it down. You can see the installation process by reconnecting you to your board with your new poppy account: ssh poppy@poppy.local password=poppy. Because of the compilation of heavy Python packages (Scipy, Numpy) it can take more than 1 hour to complete. A process will automatically take you terminal and print the installation output. You can leave it with ctrl+c. You can get back this print by reading the install_log file: tail -f install_log Be patient... At the end of the installation, your board will reboot again. You can look at the log tail -f install_log, if everything ended well, last lines should be: System install complete! Please share your experiences with the community : https://forum.poppy-project.org/ Note: If you are not sure of what going up, you can see if the install process is running with: ps up $(pgrep -f 'poppy_launcher.sh') The hostname, default user and password will be all set to \"poppy\" (ssh poppy@poppy.local password=poppy). You can test your installation with the web interface in your web browser http://poppy.local. "},"assembly-guides/ergo-jr/":{"url":"assembly-guides/ergo-jr/","title":"Assembler le Ergo Jr","keywords":"","body":"Guide d'assemblage du Ergo Jr Le robot Poppy Ergo JR est un petit bras robotique articulé à 6 degrés de liberté. Il consiste de formes très simple qui peuvent être facilement imprimées en 3D. Elles sont assemblées avec des rivets OLLO qui peuvent être montés et démontés facilement avec l'outil OLLO. L'extrêmité du bras peut être facilement changée. Vous pouvez choisir entre plusieurs outils : Une lampe. Une pince. Un porte-stylo. Les rivets employés rendent le montage et démontage des outils simples. Vous pouvez les adapter en fonction de l'activité choisie. Les moteurs ont la même fonctionnalité que d'autres créatures Poppy mais sont un peu moins puissants ou précis, l'avantage étant bien sûr qu'ils sont moins chers. La carte électronique Pixl située à côté du robot est très facile d'usage et très avantageuse pour manipuler et connecter de nouveaux capteurs. Nul soudage n'est nécessaire, il suffit d'ajouter la carte Pixl au-dessus des connecteurs de votre Raspberry Pi. Ce guide vous conduira à travers toutes les étapes nécessaires pour assembler votre Robot Poppy. Il comporte les chapitres suivants : Configuration des moteurs Assemblage de l'électronique Construction mécanique L'assemblage complet ne devrait pas prends plus d'une ou deux heures la première fois. Avec plus d'entraînement une demi heure sera largement suffisante. À la fin de l'assemblage vous aurez un Poppy Ergo Jr en état de fonctionnement, prêt à l'action ! Nous vous recommandons de suivre à la lettre les instructions même si le Ergo Jr peut-être facilement démonté, il est toujours décevant de devoir recommencer depuis zéro parce que vous avez oublié de configurer les moteurs, qu'un fil est manquant ou qu'un moteur est mis à l'envers. Liste du matériel Vous trouverez ici la liste complète du matériel requis (en Anglais : Bill of Material ou BOM) pour assembler un Poppy Ergo Jr. Materiel pour Poppy 1x carte d'extension Pixl (pour contrôler les moteurs XL320 ) 1x Disque de support disk_support.stl (utilisant la découpe laser) le plan 2D peut être trouvé ici. Vous pouvez aussi l'imprimer en 3D mais cela prendra plus de temps. Les pièces imprimés en 3D ici au format STL 1x base.stl 3x \"Palonnier à Palonnier\" horn2horn.stl 3x \"Côté à côté\" side2side.stl 1x \"U Long\" long_U.stl 1x \"U Court\" short_U.stl 1x Support caméra support_camera.stl Les différents outils 1x Abat-jour lamp.stl 1x Attache Pince gripper-fixation.stl 1x Partie Fixe Pince gripper-fixed_part.stl 1x Partie Rotative Pince gripper-rotative_part.stl 1x Porte-Stylo pen-holder.stl 1x Vis à Stylo pen-screw.stl Pièces Robotis 6x moteurs Robotis dynamixel XL-320 1x jeu de rivets OLLO (70 rivets de couleurs et 4 gris) 1x Outil OLLO Vis 4x vis M2.5x6mm (pour attacher le Raspberry Pi sur la base) 4x vis M2x5mm (pour attacher la caméra) 4x écrous M2 (pour attacher la caméra) 1x Support Male/Femelle M2.5 10mm Fournitures électroniques 1x Raspberry Pi 2 1x micro SD 8Go 1x caméra Rasperry Pi 1x alimentation AC 7.5V 2A avec un connecteur jack 2.1 x 5.5 x 9.5 (par exemple). Un cable ethernet court "},"assembly-guides/ergo-jr/electronic-assembly.html":{"url":"assembly-guides/ergo-jr/electronic-assembly.html","title":"Assembler l'électronique","keywords":"","body":"Assemblage de l'électronique Insérez la carte micro-SD dans le Raspberry Pi Assurez vous que vous utilisez une carte micro-SD préconfigurée. Si cela n'est pas le cas, vous devez \"graver\" votre carte micro-SD avec l'image ISO Ergo Jr, comme décrit dans la section démarrage. Insérez la carte micro-SD dans le Raspberry Pi: poussez la carte micro-SD dans le connecteur jusqu'à ce que vous entendiez un \"click\". Assemblez la carte d'extension pixl Attention La carte Pixl peut être acheté sur le site de Génération Robot. La Carte Pixl vous permet d'alimenter le Raspberry Pi à partir d'une alimentation 7.5V DC ou avec des piles, et vous permet de communiquer avec les moteurs XL-320. Branchez le Pixl à l'extrêmité de l'entête du Raspberry Pi. Une fois le Pixl branché (et pas avant), vous pouvez brancher une alimentation DC et les fils des moteurs. Attention Vous devez absolument éteindre l'alimentation de la carte d'extension Pixl avant de la connecter ou de déconnecter du Raspberry pi. Sinon, vous risquez de griller le convertisseur de courant de la carte Pixl. Vous pouvez à présent configurer les moteurs. "},"assembly-guides/ergo-jr/motor-configuration.html":{"url":"assembly-guides/ergo-jr/motor-configuration.html","title":"Configurer les moteurs","keywords":"","body":"Configuration des moteurs Le Ergo Jr est composé de 6 moteurs XL-320 produits par Robotis. Chacun de ces servomoteurs embarque une carte électronique lui permettant de recevoir différents types de commande (pour modifier sa position, sa vitesse ou son couple...) et de communiquer avec les autres moteurs. Ainsi vous pouvez connecter tous les servomoteurs en chaîne et les commander tous depuis le bout de la chaîne : chaque moteur passera les commandes au suivant. Cependant, pour que les moteurs soient connectés et identifiés sur le même bus ils doivent avoir un identifiant unique. A la sortie de l'usine ils reçoivent tous le même identifiant: 1. Dans ce chapitre nous allons vous expliquer comment attribuer un nouvel identifiant unique à chacun des moteurs. Nous vous recommandons de configurer les moteurs au fur et à mesure en même temps que l'assemblage du robot. Cela signifie qu'avant d'assembler un nouveau moteur, vous le configurez d'abord avant de l'assembler de suite sur le reste du robot. Cela nous empêchera d'inverser deux ou plusieurs moteurs. Durant la procédure d'assemblage pas à pas, nous vous signalerons à chaque fois qu'un moteur doit être configuré. Vous pouvez de plus configurer les moteurs à partir de l'interface Jupyter Notebook. Configurer les moteurs un par un Comme expliqué précédemment, tous les moteurs ont le même identifiant par défaut. Seul un moteur à la fois doit être connecté au Bus de Données quand vous les configurez. Sinon, cela ne fonctionnera pas et tous les moteurs connectés penseront que l'ordre envoyé sur le bus leur est destiné, ils essaieront d'y répondre ce qui sera la cause d'un sacré désordre. Votre montage électronique pour configurer les moteurs devrait ressembler à ceci: un Raspberry Pi la carte Pixl par dessus et son alimentation connectée Un fil entre la carte Pixl et le moteur que vous souhaitez configurer Un cable ethernet entre le Raspberry Pi et votre ordinateur ou votre routeur. Grâce à l'interface web (plus facile) Attention L'utilitaire Web de configuration des moteurs est toujours en cours de construction. Utilitaire de ligne de commande Les robots viennent avec un utilitaire en ligne de commande intitulé poppy-configure ; pour l'utiliser vous devez ouvrir un terminal ligne de commande sur votre Raspberry Pi. Vous pouvez accéder au Raspberry Pi directement depuis votre ordinateur. Pour se faire, ouvrez la page [http://poppy.local] dans votre navigateur web. Vous verrez la page d'accueil Poppy. Cliquez sur le lien \"Python, Terminal\" et sélectionnez \"New Terminal\". Une fois le terminal ouvert, copiez et validez avec la touche \"Entrée\" la commande ci-dessous: poppy-configure ergo-jr m1 Vous venez de configurer le moteur \"m1\" de votre robot. Une fois configuré et que vous avez vu le message confirmant que tout s'est bien passé, vous pouvez débrancher le moteur (inutile de débrancher la carte). La configuration du moteur est stockée dans la mémoire interne du moteur même. Info Les moteurs Poppy Ergo Jr sont appelés m1, m2, m3, m4, m5, m6. Pour configurer les autres moteurs, modifiez la ligne de commande ci-dessus pour remplacer \"m1\" par le nom du moteur que vous souhaitez configurer. "},"assembly-guides/ergo-jr/mechanical-construction.html":{"url":"assembly-guides/ergo-jr/mechanical-construction.html","title":"Construire la mécanique","keywords":"","body":"Construction mécanique Avis et avertissements d'ordre général Vous pouvez assembler quelques rivets avant la construction. Vous devez insérer la tige de la première partie dans le trou de la seconde. Vous pourrez ainsi les enlever facilement si nécessaire. Il y a deux types de rivets: les gris et les autres. Les rivets gris sont plus longs afin de pouvoir les insérer à travers l'axe du moteur, par le côté opposé aux palonniers d'assemblage. Utilisez l'outil OLLO pour pouvoir monter et démonter les rivets facilement. N'oubliez pas d'insérer les fils entre les moteurs quand vous construisez le robot ! Chaque moteur, mis à part le dernier de la chaîne, doit avoir deux fils : un connecté au moteur précédent et l'autre au moteur suivant (le sens de connexion n'a pas d'importance). Alignez toujours le palonnier (la roue d'entrainement noire) avec le moteur avant de les assembler! Sinon votre Poppy Ergo Jr aura l'air tout à fait bizarre... Toutes les palonniers moteur doivent être alignées sur le côté gauche du robot. C'est juste une convention mais elle définira l'orientation de vos moteurs. Guide pas à pas Configuration des moteurs (pour toutes les étapes) Vous pouvez configurer les moteurs avant, pendant ou après l'assemblage mécanique mais il est hautement conseillé de configurer chaque moteur un par un dans l'ordre de construction : Configurer moteur m1 Assembler la base et le moteur m1 Configurer le moteur m2 ... Attention Pour configurer les moteurs vous devez les connecter séparément un par un avec le Raspberry Pi. Si vous essayez de configurer un nouveau moteur alors qu'il est connecté avec le moteur précédent, cela ne fonctionnera pas. Veuillez consulter le chapitre configuration des moteurs pour plus d'informations. Etape 1 Tout d'abord, configurez un moteur XL-320 en tant que \"m1\". Montez le moteur sur la base imprimée en 3D. Pour se faire, préparez 8 petits rivets. Placez la première partie dans la seconde sans les mettre à l'intérieur du moteur. Ensuite, placez le moteur sur la base avec la palonnier faisant face au côté le plus ouvert. Utilisez l'outil OLLO pour attraper le rivet entre la première et seconde partie puis insérez le rivet dans un des trous d'assemblage. Une fois le rivet en place, verrouillez-le en poussant la partie 1 du rivet dans la partie 2. Etape 2 Configurez le second moteur (son nom est \"m2\"), avec la commande suivante dans un terminal Poppy: poppy-configure ergo-jr m2 Montez la pièce en forme de long U. Attention avec l'orientation du U, le palonnier doit être orientée sur la gauche. Montez le moteur \"m2\" au sommet de la construction. Etape 3 Configurez le moteur \"m3\". Montez la pièce \"palonnier à palonnier\" et la pièce \"palonnier à côté\" sur le moteur \"m2\" et montez \"m3\" au sommet de la construction. Etape 4 Configurez le moteur \"m4\". Montez une pièce en \"U court\" sur le moteur 4. Montez le moteur \"m4\" et la pièce en \"U court\" qui y figure au sommet de la construction. Le nez du moteur devrait être sur l'autre côté de la base. Etape 5 Configurez le moteur \"m5\". Montez la pièce \"palonnier à palonnier\" et la pièce \"palonnier à côté\" sur le moteur \"m4\", et montez \"m5\" au sommet de la construction. Etape 6 - l'outil de votre choix Configurez le moteur \"m6\". Pour achever votre Ergo Jr, vous devez ajouter un outil à son extrémité. Choisissez un outil en fonction de ce que vous souhaitez faire. Note Les outils peuvent être facilement et rapidement changer vous pouvez donc l'adapter aux différentes activités. Abat-jour ou porte-stylo Montez la pièce \"palonnier à palonnier\" et la pièce \"palonnier à côté\" sur le moteur \"m5\", et montez \"m6\" au sommet de la construction. Vous pouvez monter le porte-stylo ou l'abat-jour sur le moteur \"m6\". Pince Montez l'attache de la pince entre les moteurs \"m5\" et \"m6\". Montez la partie Fixe de pince et partie Rotative de pince sur le moteur \"m6\". Etape 7 - electronics Monter la partie support caméra sur la base. Attacher la caméra Raspberry Pi et bouger le câble caméra Flex entre le moteur \"m1\" et la base. Pour connecter le câble Flex de la caméra sur le Raspberry Pi, vous devez: Ouvrir le connecteur caméra en tirant l'attache vers le haut. Vous assurer que la face des connecteurs du câble Flex est dos au port Ethernet. Pousser le flex dans le port et repoussez l'attache plastique du port caméra vers le bas. Fils moteurs: Si ca n'est pas déjà le cas, vous pouvez connecter tous les fils moteurs. Chaque moteur a deux connecteurs mais il n'y pas ni entrée ni sortie, vous devez simplement créer une chaîne de moteurs. Le premier moteur est connecté à la carte d'extension PIXL et au second moteur; le dernier moteur est lié seulement au moteur précédent, et tous les autres sont connectés au moteur précédent. Information Les connecteurs du moteur \"m1\" (sur la base) sont un peu difficiles à connecteur, vous pouvez utiliser l'outil OLLO pour vous aider. Etape 8 - connectez votre ergo-jr au Raspberry Pi Montez votre ergo-jr sur le disque de support en bois. Montez votre Raspberry Pi sur le disque de support, et utilisez une vis 4 x M2.5x6mm pour l'arrimer. C'est Fini Prenez maintenant un verre de votre boisson préférée et détendez-vous. "},"assembly-guides/poppy-humanoid/":{"url":"assembly-guides/poppy-humanoid/","title":"Assemble the Poppy Humanoid","keywords":"","body":"Assembly guide for the Poppy Humanoid Caution The assembly guide for the humanoid has still not been merged on the new doc. You can find it on the poppy-humanoid git repository. "},"assembly-guides/poppy-torso/":{"url":"assembly-guides/poppy-torso/","title":"Assemble the Poppy Torso","keywords":"","body":"Assembly guide for the Poppy Torso Caution The assembly guide for the Poppy Torso has still not been merged on the new doc. You can find it on the poppy-torso git repository. "},"programming/":{"url":"programming/","title":"Programmation","keywords":"","body":""},"programming/snap.html":{"url":"programming/snap.html","title":"Programming with Snap!","keywords":"","body":"Programming Poppy robots using Snap! Snap! is a blocks-based graphical programming language that allows users to create interactive animations, games, and more, while learning about mathematical and computational ideas. Snap! was inspired by Scratch (a project of the Lifelong Kindergarten Group at the MIT Media Lab), but also targets both novice and more advanced users by including and expanding Scratch's features. Snap! is open-source and it is entirely written in javascript, you can use it from the official website but you can also use a copy of the website in your personal computer and open the snap.html file in your browser. Warning Even if Snap! use JavaScript and HTML5 which are browser independent technologies, opening blocks for Poppy robots in Snap! is far faster in a web browser based on Webkit engine. We strongly recommend you to use Chromium Browser (which is very similar to Chrome without tracking tools), or Google Chrome. Introduction to Snap! programming This chapter will focus on things necessary to understand in Snap! for using Poppy creatures. If you want a well designed online lesson on Snap! we strongly encourage you to look at the \"Beauty and Joy of Computing\" (BJC) course made by the University of Berkeley for New York high school students. Some of the snapshots and concepts of BJC have been used for writing this chapter. Connect your robot to Snap! If you use a simulated robot on V-REP Info You need to have installed Poppy software libraries and V-REP simulator on your computer. If it is not done, go to the install poppy software section. First open V-REP. The quickest way is to use the command line utility poppy-service. Copy and press enter to execute the command below in your command prompt (windows) or terminal (OSX and Linux): poppy-services poppy-ergo-jr --snap --vrep Substitute 'poppy-ergo-jr' with 'poppy-humanoid' or 'poppy-torso' to launch respectively a Poppy Humanoid or a Poppy Torso. It will open a Snap! tab in your web browser for a simulated poppy-ergo-jr. If it is not automatically done, you can open Snap with preloaded blocks at simu.poppy-project.org/snap/ Warning Every popup in V-REP will block the communication to the robot interface. If a popup appear, close it and restart the command above. Alternative method: Instead of using poppy-service you can start it in full python: # use PoppyTorso PoppyHumanoid or PoppyEgoJr depending on what you want from poppy.creatures import PoppyErgoJr poppy = PoppyErgoJr(simulator='vrep', use_snap=True) If you use a simulated robot on poppy-simu (web viewer) Info You need to have installed Poppy software libraries on your computer. If it is not done, go to the install poppy software section. The quickest way is to use the command line utility poppy-service. Copy and press enter to execute the command below in your command prompt (windows) or terminal (OSX and Linux): poppy-services poppy-ergo-jr --snap --poppy-simu Warning poppy-simu is only available for poppy-ergo-jr. Other creatures are only supported in V-REP. It will open a Snap! tab in your web browser for a simulated poppy-ergo-jr. If it is not automatically done, you can open Snap with preloaded blocks at simu.poppy-project.org/snap/ and the robot viewer at simu.poppy-project.org/poppy-ergo-jr. Alternative method: Instead of using poppy-service you can start it in full python: from poppy.creatures import PoppyErgoJr poppy = PoppyErgoJr(simulator='poppy-simu', use_snap=True) If you have a tangible robot First, you must be connected to the same network LAN area than your robot (e.g. on the same router or Wifi). You have to go on the web homepage of your robot with its URL. You can use its IP address (for example http://192.168.1.42) if you have a way to know it or its hostname like http://poppy.local. To find its IP address look at the zeroconf chapter. To use directly its hostname http://poppy.local you must have a Zeroconf software installed on your computer (aka \"Bonjour print services for Windows\" if you are running Windows). The home page of your poppy creature should look like the snapshot below: Click on the \"Start Snap!\" link to open the Snap! interface at start the connection with the Poppy robot. Poppy special blocks are stored in the Examples. Go to \"file\" icon -> open -> Examples -> click on \"Poppy blocks\". It may take some time to load the blocks (~5-15 seconds), be patient. Interface and general ideas Saving in Snap! There are three ways of saving a project in Snap! Save the project in your web browser When you are not logged in Snap! Cloud, the default behaviour of Snap! is to save your project in your browser. Technically this uses the Local Storage which is a memory space in your web browser where websites can store offline data. This is very convenient because you have not to register or to see Snap! project files, but keep in mind that these projects are only visible in this specific web browser in this specific computer. Snap! Cloud « There is no Cloud, it's just someone else's computer ». Instead of saving your projects on your web browser, you can save them in Snap! servers in UC Berkeley, called \"cloud\". Moreover, this allows you to share your project with anyone, with a simple link. Create an account on Snap! cloud Click on the cloud button -> \"signup...\". Fill the required fields in the modal window for signing up. You will soon receive a validation email with a random password. You can now log in with your username and password. If you use your personal computer, remember to check the \"stay signed in on this computer [...]\" checkbox. After logging in account, you are free to change your password: click on the cloud button -> \"Change Password\". Share your Snap! project The big advantage of using Snap! Cloud is the ability to share a copy of your project with anyone. To share a Snap! project, you first need to be logged in Snap! Cloud and having your current project saved (\"save\" or \"save as\"). Go to the \"open\" menu: In the cloud section, select the project you want to share and click on \"Share\" button. Here is the trick step: to see the share link, you have to click on the \"Open\" button. And this will re-open your project with the public sharing URL. You can copy and paste the URL and share it by the way you want to your friends or to the Poppy community with the forum forum.poppy-project.org. When you open a share project, the project is automatically opened in full screen on the sprite zone. To quit the full screen you have to click on the double arrow at the top of the snapshot below. Export/Import your Snap! project If you have a limited access to internet and you want to share project with other people, the best way is to export it: A new tab in your web browser will be opened with an XML file like the picture below. This file describe all your Snap! project in a a simple file. It's not made to be human readable so don't be afraid, you just have to save it on your computer. For that, do a right click, chose \"save as\" and a proper name and location on you computer for this project. If you want to import a previously exported project, you simply have to click on the import section of the file icon. Search Poppy blocks Every Poppy block in Snap! begins by a robot icon. So you can search all of them by the robot keyword. To search a specific block, do a right click on the block area, or use the keyboard shortcut CTRL+F. Network First test your connection with the (tangible or simulated) robot with the \"test connection\" block. . if the block answer is \"You may have connection troubles\", your \"host\" variable inside the Snap! project is probably wrong. The host variable must be the IP or the hostname+\".local\" of your robot ; if you're using V-REP localhost is used to point to your own computer. . Build your own blocks! The functionality to build your own block was the first difference between Scratch and Snap! (now it's also possible to make custom blocks in Scratch)! Description of Poppy blocks Description This block allows you to connect Snap! to your robot. The host input can accept : - robot_name.local (e.g. : poppy.local if your robot’s name is poppy)- the IP address (e.g. 123.124.145.176) Click on this block to verify that you are connected to your robot. Put one or many motors in compliant or stiff mode. Motors are hand-drivable in compliant mode but must be in stiff mode to controlled with Snap!.The “motor(s)” input can accept:- string of a motor name (e.g. m1)- string of many motors separated with spaces (e.g. m1 m2 m4)- a Snap! list of motors like the reporter block \"$robot all motors\"\" or the block “list”\" Put one or many motors in a position (angle in degree) in a given time.The “motor(s)” input can accept: - string of a motor name (e.g. m1) - string of many motors separated with spaces (e.g. m1 m2 m4) - a Snap! list of motors like the reporter block \"$robot all motors\"\" or the block “list”. “Wait” can be true or false. If it’s on True, the action will wait the end of the previous action. If it’s on False, then the action will proceed during the previous one.\" Restart the software inside the robot. Put the value to one register (position, speed, max torque, …) of one or many motors. Activate/deactivate color leds of motors and choose the color of your choice.The “motor(s)” input can accept: - string of a motor name (e.g. m1) - string of many motors separated with spaces (e.g. m1 m2 m4) - a Snap! list of motors like the reporter block \"$robot all motors\"\" or the block “list” Play a movement at a given speed. It is necessary to indicate the exact name of the movement previously recorded. This block can be nested in the “concurrent/sequential” block.\" All blocks in input are run one after each other.You can use this block to play concurrently many sequently move. All reports input are run simultaneously.You can use this block to play concurrently many recorded move. Create and start a movement recorded by demonstration to the given motors. Stop a record and save the recorded move in the robot.Be careful, you must have previously defined a move record with the \"create & start record move ...\"\" block. Stop a movement that is being played. Play movements at the same time (can be nested to concurrent block). Inputs can be : - move name (string) - any reporter block, like sequential or play sequentially\" Play movements following in order (can be nested to sequential block). Inputs can be : - move name (string) - any reporter block, like sequential or play sequentially Start/Stop/Pause/Resume an integrated behaviour of the robot. It can be a position, a movement, a sensorimotor loop, high level camera feature.. Play a move in reverse at a given speed (reporter block) Play a move at a given speed (command block) Give motors which are in a given group. You can know groups name with the block “all motors groups”. Return a list with the name of every motors in the robot. Give the value of a register (position, speed, load, ... ) of one or many motors. Give the position of every motors. It is a shortcut to the block above. It is useful to make a snapshot of pose of the robot. Return the index of a motor name in the \"all motors\" block list. Give the URL of the robot. For internal use only. Give all records stored in this robot. Give the list of all attached/running behaviours . Give all existing motors groups. Get all methods or functions which are runnable in a behavior.It is an advanced block. Return a boolean (true/false) depending if the selected card is detected by the camera of the robot. "},"programming/notebooks.html":{"url":"programming/notebooks.html","title":"Usage of Jupyter notebooks","keywords":"","body":"Jupyter Notebooks Gallery: using Python Most of the existing examples of using Poppy robots in Python are given as Jupyter Notebooks. We strongly encourage the use of this web application as it allows \"the creation and sharing of documents that contain live code, visualization and explanatory text\". Furthermore, they also permit the design of interface for live controlling a robot thanks to widgets. This chapter presents a gallery of notebooks and tries to organize them into different categories: Getting started Simulator HTTP API and remote connection Scientific experiments Education Going further (advanced topics) For each notebook, we provide a short description of what it does, with which robot/simulator it can be used and of course a link. Most of the notebooks are written in english but you will also find some in french (and hopefully soon in other languages). Getting started Discover your Poppy Ergo Jr: Notebook - Begin controlling your robot, launch behavior, send motor command, get values from the sensor... Controlling a Poppy Humanoid in V-REP: Notebook - Describe how to setup a Poppy Humanoid in V-REP and how to control it (motor control and sensor reading) from pypot in Python. Record, Save, and Play Moves: Notebook - Simple introduction on how to record by demonstration moves on any Poppy Creature. It also shows how they can be re-played and saved/load to/from the disk. Notebooks en français 10 choses à savoir avec Poppy Humanoid/ErgoJr et V-REP: pour l'ErgoJr, pour l'Humanoid - 10 informations de base pour bien commencer avec Poppy Humanoid ou Poppy ErgoJr simulés dans V-REP et comment les contrôler en Python. Simulator V-REP Controlling a Poppy Humanoid in V-REP: Notebook - Describe how to setup a Poppy Humanoid in V-REP and how to control it (motor control and sensor reading) from pypot in Python. Interacting with objects in V-REP: Notebook - Show how you can programtically add objects to the V-REP simulation and interact with them. This example uses a Poppy Torso but can be easily adapted to other creatures. Learning the robot IK: Notebook - Demonstrate how explauto can be used to learn the inverse kinematics of a Poppy Humanoid. The experiments are run in V-REP simulation but it also gives hints on how it can be transposed in the real world. Notebooks en français 10 choses à savoir avec Poppy Humanoid/ErgoJr et V-REP pour l'ErgoJr, pour l'Humanoid - 10 informations de base pour bien commencer avec Poppy Humanoid ou Poppy Ergo Jr simulés dans V-REP et comment les contrôler en Python. HTTP REST API and remote connection Controlling a robot using HTTP requests: Notebook - Show how you can send HTTP requests to a robot, using the REST API, to control it. The notebook is based on a V-REP simulated Poppy Humanoid but can be adapted to other creatures. Scientific experiments Discover Explauto Learning the robot IK: Notebook - Demonstrate how explauto can be used to learn the inverse kinematics of a Poppy Humanoid. The experiments are run in V-REP simulation but it also gives hints on how it can be transposed in the real world. Demo interface Primitives launcher for Poppy Humanoid: Notebook - Provides all codes needed to directly launched primitives (stand, sit, idle motions, limit torque...) Education Notebooks en français Initiation à l'informatique en Lycée Découverte: TP1, TP2, TP3 - Comprendre comment faire bouger simplement le robot. Utilisation des boucles. Ces TPs utilisent un Poppy Torso simulé dans V-REP. Dialogue: TP1, TP2 - Établir un dialogue entre Python et le robot. Ces TPs utilisent un Poppy Torso simulé dans V-REP. Going further Low-level communicatio Debug and setup Benchmark Extending Poppy software Contributing to this gallery Do not hesitate to let us know if some cool Notebooks are missing! You can directly send pull-request on GitHub or use the issue tracker. "},"programming/python.html":{"url":"programming/python.html","title":"Programming in Python","keywords":"","body":"Programming Poppy robots in Python This chapter will guide you through how to control Poppy robots in Python. As it is actually the language used for writing Poppy core libraries, you will see how to access all the different levels of control, from the higher to the lower. We will detail everything you need to know to directly program you robot using the Python embedded in the Poppy robot or to install everything locally. Note that this chapter does not intend to teach you Python or programming from scratch and thus if you are completely new to Python it may be good to start with a Python tutorial. Yet, we try to keep the tutorials as simple as possible and we will always warn you when some parts are targeting more advanced users. We will try to provide as many examples as possible and point to the complete API so you can find and use the least famous features. Most of the examples and tutorials are available as a collection of Jupyter notebooks. The next chapter, Jupyter Notebooks Gallery, presents a list describing each notebook, what they will teach, what they can be used for, for which robot, etc. All Poppy libraries are open source and are released under the GPL v3 license. So you can freely access the source code on github. Do not hesitate to fork them, send pull request and contribute! Why Python and Anaconda? The libraries developed for the Poppy project were designed with the aim to make it easy and fast to write code for controlling various robots based on - originally - robotis dynamixel motors. The idea was to provide access from the lower level - raw serial communication with a specific motor for instance - to higher levels such as starting and stopping primitives/behaviors (e.g. face tracking, postures, ...) or directly recording motions through learning by demonstration. We decided to write most of them in Python as its flexibility allows for fast and modular development. It was also meant to be accessible by a large audience, from developers and roboticists in general, to hobbyists, researchers, artists... Python was also chosen for the tremendous pools of existing libraries (scientific, computer vision, IO, web...) so if one is interested in adding a new feature, such as support for a new motor/sensor, it should be as easy and fast as possible. Finally, support for multiplatforms and ease of installation were also key aspects. We also strongly advise to use the Anaconda Python distribution as it already includes most of the libraries needed by the Poppy libraries. We also provide all poppy libraries as conda recipes so they can be easily install using Anaconda (see the install section). Overview of the different libraries Info A more detailled documentation of these software libraries is available in the software libraries section Before jumping into the code, we will briefly introduce the different existing Poppy libraries and how they interact with each other. They are three main library levels: pypot: This is the core of the Poppy software architecture. Pypot handles all the low level communication with the hardware (both sensors and motors), defines synchronization loops so your command are always up to date. It also provides the primitives mechanism which allows the definition of simple behavior that can be - more of less - automatically combined. poppy-creature: This library defines the common tools shared by all Poppy robots, for instance how to automatically launch the simulator or start the HTTP API attached to any robot. poppy-ergo-jr, poppy-torso, and poppy-humanoid: Those libraries are specific to their respective Poppy robot. They define the particular configuration of the robot, the sensors it uses, which motors are connected to which buses... This is also were behaviors specific to a creature are defined (the stand primitive for the humanoid for instance). This is summarized in the diagram below: Installation First, note that if you are only planning to use real robots, they already come with Python and all Poppy libraries installed. You can directly connect to the Jupyter notebook server via the web interface and have nothing to install on your machine! What you need to install is summarized in the diagram below: Yet, if you are planning to either Use a simulator (e.g. V-REP, or web simulator), or want to directly plug the robot to your computer You will have to install Poppy libraries locally. They work on Windows, Mac OSX, Linux, and have been tested on: Python >= 2.7 Python >= 3.4 Also note that if you are planning to directly plug your robot to your USB port, specific drivers should be installed. All steps are detailed in the chapter install Poppy software. Quickstart: Hello Poppy world! To give you a rapid overview of what you can do using Python to program Poppy robots, this section will show you how to: Create and connect your robot Retrieve values from the sensor and send motor commands Start playing with primitive by recording motions by demonstration This section does not intend to cover everything that can be done in Python with Poppy but to give you sneak peaks of the most common features. For more advanced use, you should refer to the next section where we present a list of Jupyter notebooks each detailing a specific aspect or feature. In the following examples, we assume that you have a working environment meaning that you either: are using the Python embedded in your robot: through the Jupyter Notebook server, or you have installed everything locally to work with a simulator. Create and connect to a Poppy robot Import the library The very first step you have to do to start programming Poppy robots in Python is to import the library. In Python they are called module or package. To do that, you write something similar to: from poppy.creatures import * This will actually import all Poppy robots installed on the Python distribution you are using. If you want to use a specific robot, you can replace the * (which means all here) by the name of the robot you want. For the ErgoJr: from poppy.creatures import PoppyErgoJr For the Torso: from poppy.creatures import PoppyTorso For the Humanoid: from poppy.creatures import PoppyHumanoid Note If you see an error similar to the one below when executing the previous line, this means that the libraries are not correctly installed. See the section install Poppy software. In [1]: from poppy.creatures import PoppyHumanoid ImportError Traceback (most recent call last) in () ----> 1 from poppy.creatures import PoppyHumanoid ImportError: cannot import name PoppyHumanoid Create the Robot object - with a real robot Then, you can actually create the Python object that will represent your robot. Depending on the Poppy robot you are using: # if you are using an Ergo Jr poppy = PoppyErgoJr() or # if you are using a Torso poppy = PoppyTorso() or # if you are using a Humanoid poppy = PoppyHumanoid() And that's it, if you did not see any error message it means that you are connected to your robot. If you see an exception like the one shown below, you should check the wire connection and try again: IOError: Connection to the robot failed! No suitable port found for ids [3, 5, 7, 11, 13, 17]. These ids are missing [3, 5, 7, 11, 13, 17] ! Create the Robot object - with V-REP To use a simulated robot instead of a real one, you only have to specify it when creating the Robot object. For instance, if you want to create a simulated Poppy Torso, you simply have to execute the following line: poppy = PoppyTorso(simulator='vrep') All three Poppy robots - Humanoid, Torso, and Ergo Jr - can be used with V-REP. If you see an error message like this, check that you have launched V-REP and that you have close the popup in V-REP (see this chapter for details). IOError: Connection to V-REP failed! Create the Robot object - with web simulator Currently only the Ergo Jr is usable within the web simulator. It also requires specific versions of libraries to be used properly. To make sure you meet these requirements, you can type this command from your shell: pip install pypot>=2.12 poppy-creature>=1.8 poppy-ergo-jr>=1.6 --upgrade You can then instantiate the poppy-ergo-jr creature: poppy-services --poppy-simu --snap --no-browser poppy-ergo-jr This will create a server for Snap! on port 6969, and a server for the visualizer on port 8080. You can then head to the visualizer page. Access the sensors and motors The robot object you just created contains two main groups of objects: motors sensors that can be easily access using poppy.motors and poppy.sensors. As soon as the robot object is created it automatically starts synchronization loops which will ensure that the last available value are received/sent to the robot. Note Servomotors that are used in Poppy robots can be seen as both motors and sensors. Indeed, on top of being \"simple\" motors, they also provide multiple sensing information: their current position, speed and load but also their temperature, the current used... Yet, for simplification they are only available under the motor category. Get data from your robot Now that you have created your robot object, you can directly use Python to discover which motors are attached. Note In all examples below the results are shown for an ErgoJr. If you are using a Torso or a Humanoid you will see more motors with different names. For instance, to know how many motors your robot have you can execute: print(len(poppy.motors)) poppy.motors is actually a list of all motors connected to your robot. Thus, if you want to get the present position of all motors, you can do: for m in poppy.motors: print(m.present_position) Of course, you can also access a specific motor. To do that, you need to know the name for the motor you want to access. You can find this list in the assembly documentation of your robot. You can also get a list of all motors name directly from python: for m in poppy.motors: print(m.name) or using a motor pythonic expression: print([m.name for m in poppy.motors]) Then you can directly access the desired motor by its name: m = poppy.m3 or get its position: print(poppy.m3.present_position) The most common values for motors are: present_position present_speed present_load Similarly, you can get data from your sensors. Depending on the Poppy robot you have different sensors available. You can get the list of all sensors in the exact same way you did for motors: print([s.name for s in poppy.sensors]) And then access a specific sensors by its name. For instance, to get an image from the camera of the Ergo Jr: img = poppy.camera.frame Note This section just presented some of the available values that you can get from your motors/sensors. They are many other - some are specific to a particular robot - we will present them through the different notebooks. Send motor commands Now that we have shown you how to read values from your robot, it is time to learn how to make it move! This is actually really similar to what you have just seen. Instead of getting the present_position of a motor you simply have to set its goal_position. But first, you have to make sure your motor is stiff, meaning that you cannot move it by hand. To do that we will turn off its compliancy. Assuming you have an Ergo Jr and want to make the motor m3 moves - feel free to use any other motor but make sure the motor can freely move without hurting any of your finger: poppy.m3.compliant = False The motor should now be stiff. And then, to make it move to its zero position: poppy.m3.goal_position = 0 Note: present_position and goal_position are actually two different registers. The first refers to the current position of the motor (read only) while the second corresponds to the target position you want your robot to reach. Thus, they can have different values while the motor is still moving to reach its goal_position. As a slightly more complex example we will make it go to 30 degrees then -30° three times: import time for _ in range(3): poppy.m3.goal_position = 30 time.sleep(0.5) poppy.m3.goal_position = -30 time.sleep(0.5) Note that after each new value set to goal_position we wait so the motor has enough time to actually reach this new position. Another way to do the same thing is to use the goto_position method: import time for _ in range(3): poppy.m3.goto_position(30, 0.5, wait=True) poppy.m3.goto_position(-30, 0.5, wait=True) As you can see, this method takes three arguments, the target position, the duration of the move and whether to wait or not the end of the motion. If you want to move multiple motors at the same time, you can simply do something like: for _ in range(3): poppy.m1.goal_position = -20 poppy.m3.goal_position = 30 time.sleep(0.5) poppy.m1.goal_position = 20 poppy.m3.goal_position = -30 time.sleep(0.5) or use a python dictionary storing the target position per motor you want to move, that can be given to the goto_position method: pos_1 = {'m1': -20, 'm3': 30} pos_2 = {'m1': 20, 'm3': -30} for _ in range(3): poppy.goto_position(pos_1, 0.5, wait=True) poppy.goto_position(pos_2, 0.5, wait=True) Note You can turn a motor back to its compliant mode (where you can freely move it) by setting its compliant register to True: poppy.m3.compliant = True Record and play motion by demonstration using primitives Pypot provides you with the primitive mechanism, which are simply pre-defined behaviors that can be attached to your robot. In this section, we will show you how to use some primitives already existing for recording and playing motions. You can also define your own primitive but this is out of the scope of this section, you will find details on how to do this in dedicated notebooks. Record a motion by demonstration Designing choreographies for your robot using goal_position or goto_position can be long and kind of troublesome. Fortunately, there is a much more efficient way of doing this: recording motions by directly demonstrating the move on the robot. This can be summarized into few steps: make the robot compliant so you can move it by hand start the recording actually moves the robot so it follows whatever move/choreography you can think of stop the recording And now to do that in Python: So, first we turn all motors of the robot compliants: for m in poppy.motors: m.compliant = True Info You can also record a movement with motors stiff (compliant = False), and moving them with goal_position or goto_position commands. Then, we have to include the primitive used for recording motion: from pypot.primitive.move import MoveRecorder To create this primitive, you have to give the following arguments: on which robot you want to use this primitive (this can be useful if you are working with multiple robot at a time - for instance you can record a move on a robot and at the same time make it reproduce by another one. the record frequency of the move you want to register: how many position per second will be recorded - the higher the more accurate the record will be but also more data will have to be processed - good values are usually between 10Hz and 50Hz. the motors that you want to record. you can record a move on a subpart of you robot, for instance only on the left arm. Here, we will record a move on the whole robot at 50Hz: recorder = MoveRecorder(poppy, 50, poppy.motors) Note We used poppy.motors to specify that we want all motors if you only want let's say the two first motors of an Ergo Jr you could have used [poppy.m1, poppy.m2] instead. Now it is time to record. As it can be hard to both move the robot and type Python command at the same time, we will make a small script, that: wait 5s so you can get ready to record start the record record for 10 seconds stop the records import time # Give you time to get ready print('Get ready to record a move...') time.sleep(5) # Start the record record.start() print('Now recording !') # Wait for 10s so you can record what you want time.sleep(10) # Stop the record print('The record is over!') record.stop() Now, you should have a move recorded. You can retrieve it from the recorder primitive: my_recorded_move = record.move and check how many positions where recorded: print(len(my_recorded_move.positions())) Replay recorded moves Now to play back recorded motions you have to use another primitive: MovePlayer from pypot.primitive.move import MovePlayer player = MovePlayer(poppy, my_recorded_move) As you can see, to create it you have to specify the robot (as for the MoveRecorder) and the move you want to play. Note Automatically all recorded motors become stiff to be able to play the move. Then, you can simply start the replay: player.start() And if you want to play it three times in a row: for _ in range(3): player.start() player.wait_to_stop() We use the wait_to_stop method to make sure we wait for the first move to finish before we start another. By default, playing a move we will not block to allow you to play multiple move in parallel. Write a simple sensori-motor loop Robotic is all about sensori-motor loops, meaning that motor commands will be more or less directly related to the sensor readings. In other terms the robot actions will be determined by what it perceives from its environment. Poppy libraries and more particularly pypot provides you with tools to easily write sensori-motor loops. We will show here a very simple example where some motor of an Ergo Jr will be controlled by the position of other motors in order to keep the head of the Ergo Jr straight. To do that, we will free the two first motors, so they can be moved by hand. Two other motors will try to lively compensate the motion applied on the free motors. We need few simple steps: read values from sensors (here the two free motors) compute command from those readings set new motor command go back to step 1. Note This example is designed for the Ergo Jr. It could be adapted to other Poppy robots, by changing the motors used. Yet, it is not that obvious which one to use to have a \"cool\" result. Demo version Before writing the sensori-motor loop, we will first set the Ergo Jr in a base position. from poppy.creatures import PoppyErgoJr jr = PoppyErgoJr() jr.goto_position({'m1': 0., 'm2': -60., 'm3': 55., 'm4': 0., 'm5': -55., 'm6': 60.}, 2., wait=True) Then, we make sure the moving speed of the motors are not too high to prevent shaky motions: for m in jr.motors: m.moving_speed = 250 Finally, we free the two first motors: jr.m1.compliant = True jr.m2.compliant = True Now, that everything is setup we write our very simple sensori-motor loop like this: import time while True: # Step 1 p1 = jr.m1.present_position p2 = jr.m2.present_position # Step 2 g1 = -p1 g2 = -p2 # Step 3 jr.m4.goal_position = g1 jr.m6.goal_position = g2 time.sleep(.02) Step 1: As you can see, here our readings step is simply to retrieve the present_position of the motors m1 and m2. Step 2: Here, we defined the base position so the motors m1/m4 and m2/m6 are parallel. Thus, to compensate the head position, we simply have to define the new motor goal position as the opposite of the read present position. Step 3: We simply set the goal position as the just computed command Those steps are included inside an infinite loop - with a time.sleep to avoid CPU overhead. Note To stop this while True loop, you will have to use the classical Ctrl-c, or use the stop button if you are running it through Jupyter. Now with a primitive But what about if you want to make this behavior an independent \"brick\" that you can start/stop on demand combine with other behaviors. Well, primitives are meant to do just that. There is two main types of primitive: Primitive and LoopPrimitive. The first one basically gives you access to just a run method where you can do everything you want on a robot. The second one as the name indicates is an infinite loop which calls an update method at a pre-defined frequency. In our case it is the more suited one. Here is the entire definition of this primitive: class KeepYourHeadStraight(LoopPrimitive): def setup(self): for m in self.robot.motors: m.compliant = False self.robot.goto_position({'m1': 0., 'm2': -60., 'm3': 55., 'm4': 0., 'm5': -55., 'm6': 60.}, 2., wait=True) for m in self.robot.motors: m.moving_speed = 250 self.robot.m1.compliant = True self.robot.m2.compliant = True def update(self): self.robot.m4.goal_position = -self.robot.m1.present_position self.robot.m6.goal_position = -self.robot.m2.present_position As you can see, there is two main parts. The setup method which defines what needs to be done to prepare the robot before starting the behavior - here simply puts it in its base position and turn on the compliance for the two first motors. And the update method which will be regularly called: here is where we put the actual code for the sensori-motor loop: reading sensor - computing the new command - and sending the new command to the motors. Now that we have defined our primitive, we can instantiate it and start it: # we specify we want the primitive to apply on the jr robot instance # and that the update method should be called at 50Hz head_straight = KeepYourHeadStraight(jr, 50.0) head_straight.start() You can stop it whenever you want: head_straight.stop() And re-starting it again... head_straight.start() The huge advantage of using a primitive in this case is that after starting it, you can still easily run any other codes that you want. The primitive starts its own thread and thus runs in background without blocking the execution of the rest of the code. "},"programming/rest.html":{"url":"programming/rest.html","title":"Robots APIs","keywords":"","body":"Use the REST API to control a Poppy Robot Caution This page is not currently written. Your help is welcome to fulfill it ! "},"demo-activities/":{"url":"demo-activities/","title":"Activities","keywords":"","body":"Gallery of activities Caution This section is not currently written. Your help is welcome to fulfill it ! "},"demo-activities/snap4arduino.html":{"url":"demo-activities/snap4arduino.html","title":"Link with Snap4Arduino","keywords":"","body":"Contrôler Poppy avec un Arduino via Snap4Arduino Written by Gilles Lassus. Objectif : contrôler un moteur de Poppy par un potentiomètre sur la platine Arduino. Préparation de Snap4Arduino Téléchargez et installez Snap4Arduino. Téléchargez les blocs pypot-snap-blocks.xml. Ils devront être importés dans Snap4Arduino à chaque démarrage. Préparation de l'Arduino Connectez votre platine, ouvrez Arduino et téléversez le firmware StandardFirmata. (disponible via Fichier - Exemples - Firmata). Branchez un potentiomètre sur la sortie analogique A0, comme illustré ci-dessous : Lancement de la simulation (dans le cas d'un Poppy simulé dans Vrep) Lancez Vrep . Exécutez les commandes python suivantes : from poppy.creatures import PoppyHumanoid poppy = PoppyHumanoid(simulator='vrep', use_snap=True) puis poppy.snap.run() Ouverture de Snap4Arduino Lancez Snap4Arduino et importez les blocs pypot-snap-blocks.xml. (une fenêtre avertissant que le projet importé a été créé par Snap! apparaît ; elle est sans conséquence.) Dans les blocs Arduino, cliquez sur Connect Arduino pour établir la connexion entre Snap4Arduino et votre platine. Un message de confirmation apparaît, signe que la connexion est effective. Commander un moteur via le potentiomètre La valeur analogique lue dans A0 est un entier entre 0 et 1024. Pour la \"mapper\" entre (environ) -40 et 40, on la divise par 12 avant de lui soustraire 40. On peut donc alors construire l'instruction suivante, qui fera bouger le moteur head_z de Poppy entre -40° et +40° : Remarques diverses Il peut être utile de créer un bloc map équivalent à la fonction éponyme d'Arduino, permettant de mettre à l'échelle automatiquement une valeur dans une plage donnée : Le script de commande du moteur head_z de Poppy entre -40° et 40° deviendrait alors : Cette méthode de contrôle a pour principal défaut de \"bloquer\" la carte Arduino avec le StandardFirmata : il serait plus agréable de pouvoir simplement lire les données du port série envoyées par l'Arduino, et ainsi pouvoir téléverser le programme de son choix dans l'Arduino. Ceci est discuté ici. Toutefois, la page du projet Snap4Arduino liste les composants annexes (LCD display, UltraSound Sensor) pouvant être directement contrôlés, et explique en détail comment modifier le StandardFirmata pour intégrer un nouveau composant. "},"from-simulation-to-real-robot/":{"url":"from-simulation-to-real-robot/","title":"From simulation to real robot","keywords":"","body":"Switching from a simulated to a real Poppy robot A key feature of the Poppy project is to let you, as seamlessly as possible, switch from a simulated robot (e.g. using V-REP) to a real one. It is particularly useful when: Developing an experiment where you can setup everything using the simulation, then run it on the real robot. Working in a classroom context where students can work on their own computer via the simulation and share a robot for real world tests While it has been designed to cut the effort needed to switch from one to the other, there are still a few steps to understand. One of the major difference is when you are working in simulation everything runs on your own computer while when you are using a real robot, the software (e.g. the Python Notebooks) actually runs in the robot. "},"from-simulation-to-real-robot/using-jupyter.html":{"url":"from-simulation-to-real-robot/using-jupyter.html","title":"Program with Jupyter notebooks on the real robot","keywords":"","body":"Using Jupyter Python Notebooks One of the advantages of working with Jupyter Notebooks is the possibility to use it as a client/server approach.Each Poppy robot hosts a Jupyter server accessible via the web interface (see section quickstart for details). When working in simulation, everything is run and stored locally on your computer. When working with a real robot you can program it from a web browser on your own machine but your notebooks are actually stored and run in the robot. Thus to switch from simulation to a real robot, you need to switch from your local instance of Jupyter to the remote one hosted by the robot. The steps are described below. Connect to the Jupyter on the robot Once connected to the robot web interface http://poppy.local (we will assume here its hostname is poppy, just replace it by the new hostname if you changed it), you should see a open Ipython notebook link. When clicked it will start Jupyter on the robot and redirect you to the Jupyter webserver. You should then see the root of the notebook folder hosted on the robot: This is where you can put your own notebooks. Of course, you can create folder, organize them as you want, etc... Note: If you need finer access or more advanced configuration (such as permission for instance), you have to log directly to the robot using ssh. Upload a notebook Once connected to the Jupyter server hosted by the robot, you can directly use the Jupyter interface for uploading new notebooks. The circled button let you upload your local notebook, so stored on your own machine, to the robot. They can then be directly run on the robot. Be aware that at the moment, we do not deal with sessions or permissions (as JupyterHub does for instance), and thus anyone with access to the robot can use or delete all notebooks stored in the robot. Adapt your code There is few places where you should actually modify your code so it works with a real robot. We try to minimize the effort needed as much as possible, yet some steps are still required. Instantiation When creating the robot, you actually need to specify if you are willing to work with a real or a simulated robot. This is simply done via a parameter. For instance: When working with V-REP: from poppy.creatures import PoppyHumanoid poppy = PoppyHumanoid(simulator='vrep') Will become for a real robot: from poppy.creatures import PoppyHumanoid poppy = PoppyHumanoid() Of course, this works for all existing Poppy creatures: Humanoid, Torso and ErgoJr. This is most of the changes that you should do. Specific APIs Some part of the API are platform specific. For instance, when using V-REP you have access to tracking features that let you retrieve any object 3D position. Of course, such method do not have a real world equivalent and thus are not available when working with a real robot. A good practice if you want to write code compatible for both cases is to use the simulated property. It is automatically set to the correct value depending on how your instantiate your robot. For instance, poppy = PoppyHumanoid(simulator='vrep') def reset_position(): if poppy.simulated: poppy.reset_simulation() else: print('Ask one internship student to put the robot back in its origin position.') time.sleep(10) Version and 3rd party libraries The main drawback of this client/server way of working is that your locally installed software versions may differ from the one installed on the robot. The Python installed on the robot is Python 2.7 and comes with most of the scientific main libraries (numpy, scipy, matplotlib, opencv). An exhaustive list of the installed Python packages will be available soon . At the moment, the easier way to get it is to used a terminal notebook which can be directly run from the Jupyter interface. Using the same technique, you can install 3rd party libraries directly on the robot. The pip and conda utility tools are installed and should be used when possible. Note that the embedded board are based on armv7 and thus some libraries may be hard to compile. We are maintaining a list of conda recipes specifically built for this platform here.Contributions are more than welcomed! "},"from-simulation-to-real-robot/using-snap.html":{"url":"from-simulation-to-real-robot/using-snap.html","title":"Snap! on the real robot","keywords":"","body":"Using Snap! Caution This page is not currently written. Your help is welcome to fulfill it ! "},"software-libraries/":{"url":"software-libraries/","title":"Software libraries documentation","keywords":"","body":"Software libraries This section will provide software documentation of various libraries used in Poppy robots. Pypot Poppy-creature Poppy Ergo Jr Poppy Humanoid Poppy Torso "},"software-libraries/pypot.html":{"url":"software-libraries/pypot.html","title":"Pypot","keywords":"","body":"Pypot library Caution Pypot documentation has still not been merged in the new documentation. You can find it at poppy-project.github.io/pypot/ "},"software-libraries/poppy-creature.html":{"url":"software-libraries/poppy-creature.html","title":"Poppy-creature","keywords":"","body":"Poppy-creature library Introduction Poppy-creature is a small library providing an abstract interface for robots (Poppy Humanoid, Poppy Torso, Poppy Ergo Jr...). It links high level controls and pypot, the generic low level library. It mainly contains the class definition of poppy.creatures.abstractcreature.AbstractPoppyCreature which takes a configuration and builds a pypot.robot.robot.Robot out of it, but also a bunch of parameters to launch Snap! or HTTP servers, or to replace the communication toward Dynamixel servos by a communication with a simulator. The arguments you can provide are: base_path default: None Path where the creature sources are. The librarie looks in the default PATH if not set. config default: None Path to the configuration file with respect to the base-path simulator default: None Possible values : 'vrep' or 'poppy-simu'. Defines if we are using a simulator (and which one) or a real robot. scene default: None Path to the scene to load in the simulator. Only if simulator is vrep. Defaults to the scene present in the creature library if any (e.g. poppy_humanoid.ttt). host default: 'localhost' Hostname of the machine where the simulator runs. Only if simulator is not None. port default: 19997 Port of the simulator. Only if simulator is not None. use_snap default: False Should we launch the Snap! server snap_host default: 0.0.0.0 Hostname of the Snap! server snap_port default: 6969 Port of the Snap! server snap_quiet default: True Should Snap! not output logs use_http default: False Should we launch the HTTP server (for http_host default: 0.0.0.0 Hostname of the HTTP server http_port default: 8080 Port of the HTTP server http_quiet default: True Should HTTP not output logs use_remote default: False Should we launch the Remote Robot server remote_host default: 0.0.0.0 Hostname of the Remote Robot server remote_port default: 4242 Port of the Remote Robot server sync default: True Should we launch the synchronization loop for motor communication The sources are available on GitHub. Poppy services Poppy-creature also provides a command line utility poppy-services. It provides shortcuts to start services like SnapRemoteServer and HTTPRemoteServer from your terminal. Example: poppy-services poppy-ergo-jr --snap --no-browser This will launch the SnapRemoteServer for a real Poppy Ergo Jr robot. Note The --no-browser option avoid the automatic redirection to the Snap! webpage. You can remove it if you use a computer with a GUI (e.g your laptop instead of the robot embedded board). Another example: poppy-services poppy-ergo-jr --snap --poppy-simu It will open a Snap! windows for a simulated poppy-ergo-jr. The way to use it is: poppy-services the available options are: --vrep: creates the specified creature for using with V-REP simulator --poppy-simu: creates the specified creature for using with web simulator and also launches the HTTP server needed by poppy-simu. Poppy-simu is only available for poppy-erg-jr for now. --snap: launches the Snap! server and directly imports the specific Poppy blocks. -nb or --no-browser: avoid automatic start of Snap! in web browser, use only with --snap --http: start a http robot server --remote: start a remote robot server -v or --verbose: start services in verbose mode (more logs) Create your own Poppy creature While developping a new Poppy creature, it is first easier to simply define it in a configuration file or dictionnary and instanciate a pypot.robot.robot.Robot from Pypot directly. But when you want to make it easily usable and available to non-geek public, the best is to create your own creature's library. It should contain a configuration file and a class that extends poppy.creatures.abstractcreature.AbstractPoppyCreature. You can then add your own properties and primitives. Example from Poppy Humanoid: class PoppyHumanoid(AbstractPoppyCreature): @classmethod def setup(cls, robot): robot._primitive_manager._filter = partial(numpy.sum, axis=0) for m in robot.motors: m.goto_behavior = 'minjerk' for m in robot.torso: m.compliant_behavior = 'safe' # Attach default primitives: # basic primitives: robot.attach_primitive(StandPosition(robot), 'stand_position') robot.attach_primitive(SitPosition(robot), 'sit_position') # Safe primitives: robot.attach_primitive(LimitTorque(robot), 'limit_torque') Package your code it properly using setuptools. For a better integration with the Poppy installer scripts, please have in the root of your repo a folder named software containing: the installation files (setup.py, MANIFEST, LICENCE) a folder named poppy_yourcreaturename containing your actual code At the end, don't forget to share it to the community! Most interesting creatures will be added to this documentation! Installing Info poppy-creature library is a dependancy of any Poppy robots libraries, so you don't have to install it by hand in a normal case. To install the poppy-creature library, you can use pip: pip install poppy-creature Then you can update it with: pip install --upgrade poppy-creature If you prefer to work from the sources (latest but possibly unstable releases), you can clone them from GitHub and install them with (in the software folder): python setup.py install "},"software-libraries/poppy-ergo-jr.html":{"url":"software-libraries/poppy-ergo-jr.html","title":"Poppy Ergo Jr","keywords":"","body":"Poppy-ergo-jr library Caution This section need to be completed, contribution are welcome ! "},"software-libraries/poppy-humanoid.html":{"url":"software-libraries/poppy-humanoid.html","title":"Poppy Humanoid","keywords":"","body":"Poppy-humanoid library Caution This section need to be completed, contribution are welcome ! "},"software-libraries/poppy-torso.html":{"url":"software-libraries/poppy-torso.html","title":"Poppy Torso","keywords":"","body":"Poppy-torso library Caution This section need to be completed, contribution are welcome ! "},"appendix/network.html":{"url":"appendix/network.html","title":"Network","keywords":"","body":"Network This section will contain a collection of tips for avoiding network troubles. Where is Poppy ? If you are looking for your robot on your network, look at the zeroconf chapter. "},"appendix/contribute.html":{"url":"appendix/contribute.html","title":"Contribute","keywords":"","body":"Getting involved in the Poppy project If you want to take part of this project, maybe the first step is to become a member of the community on the Poppy forum. The forum is the very central place to exchange with users and contributors. You can freely come and talk about your project or ideas with your prefered language. There are many ways to contribute to this project as the Poppy project involves a very large scope of disciplines: Engineering fields such as AI, computer science, mechanics, electronics, machine learning... Humanities such as cognitive science, psychology... Life science such as biology, biomechanics,... Community management, scientific mediation, communication... Design such as web design, object design, UX,... Art with the need of animator to create the illusion of life and emotions. If you have no idea how you could help but you would want to, you are very welcome and you can take a look at open issues on our GitHub and call for contributions. For github ninja, you can of course create issues to notify a problem or develop new amazing features and open pull requests to integrate your idea. "},"appendix/faq.html":{"url":"appendix/faq.html","title":"FAQ","keywords":"","body":"FAQ Caution This Page is not currently written. Your help is welcome to fulfill it ! If you have any question please fill free to ask on the Poppy forum. General issues Quote Motors seems to be tired (low torque, jerky, ...), what can I do ? Change your wires ! "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Glossaire Conciliant (concernant un moteur) Un moteur est dit conciliant s'il n'oppose aucune résistance à la force. L'état contraire de conciliant est résistant. "},"assembly-guides/":{"url":"assembly-guides/","title":"Guides d'assemblage","keywords":"","body":"Guides d'assemblage Cette section fournit la documentation pas-à-pas de l'assemblage des robots Poppy. Assembler le Ergo Jr Assemblage électronique Configuration des moteurs Construction du matériel Assembler l'Humanoïde Poppy Assembler le Torse Poppy "},"appendix/":{"url":"appendix/","title":"Appendices","keywords":"","body":""}}